<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Neon Snake Clean</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

<style>
:root{
--ui-scale:1;
}
body{
margin:0;
display:flex;
justify-content:center;
align-items:center;
height:100dvh;
background: radial-gradient(circle at center, #1a0f00, #000000);
font-family: Arial, sans-serif;
overflow:hidden;
touch-action:none;
overscroll-behavior:none;
-webkit-user-select:none;
user-select:none;
-webkit-tap-highlight-color: transparent;
}
canvas{
position:absolute;
width:min(92vmin, 720px);
height:min(92vmin, 720px);
border-radius:20px;
box-shadow:0 0 50px #ff7a00;
z-index:0;
pointer-events:none;
}
.menu{
position:absolute;
top:50%;
left:50%;
transform:translate(-50%, -50%) scale(var(--ui-scale));
transform-origin:center center;
z-index:10;
background:rgba(0,0,0,.75);
padding:30px;
border-radius:20px;
text-align:center;
box-shadow:0 0 40px #ff7a00;
width:min(92vw, 520px);
max-height:min(88vh, 760px);
overflow-y:auto;
}
button{
margin:5px;
padding:10px 20px;
border:none;
border-radius:8px;
cursor:pointer;
background:#ff7a00;
}
button:hover{background:#ff5500;}
.hidden{display:none;}
#historyActions{
    margin-top:12px;
    display:flex;
    gap:8px;
    justify-content:center;
    flex-wrap:wrap;
}
#gameOverMenu h2{
    color: white;
}
#finalScore{
    color: white;
}
#gameOverMenu p{
    color: white;
}
#gameOverTrophies{
    display:none;
    margin-top:6px;
    color:#ffb45c;
    text-shadow:0 0 10px rgba(255,122,0,0.45);
    font-weight:700;
}
#gameOverTrophiesDelta{
    margin-left:6px;
    font-weight:700;
}
#gameOverTrophiesDelta.pos{
    color:#7CFC00;
    text-shadow:0 0 8px rgba(124,252,0,0.55);
}
#gameOverTrophiesDelta.neg{
    color:#ff6b6b;
    text-shadow:0 0 8px rgba(255,107,107,0.45);
}
#trophyCount,
#coinCount,
#gameOverTrophiesValue{
    display:inline-block;
    transform-origin:center center;
    transition:transform 0.28s ease, filter 0.28s ease;
}
.trophy-pop{
    transform:scale(1.32);
    filter:brightness(1.32);
}
@media (max-width: 900px){
    #gameOverTrophies{
        display:block;
    }
}
@keyframes neonGlow{
    0%,100%{
        text-shadow:
            0 0 5px #ff7a00,
            0 0 15px #ff7a00,
            0 0 30px #ff9d2f;
    }
    50%{
        text-shadow:
            0 0 10px #ff7a00,
            0 0 25px #ff7a00,
            0 0 50px #ff9d2f;
    }
}

#title{
    color:#ff7a00;
    animation: neonGlow 1.5s infinite;
}
#keys{
    position:absolute;
    bottom:max(20px, env(safe-area-inset-bottom));
    left:max(20px, env(safe-area-inset-left));
    transform:scale(var(--ui-scale));
    transform-origin:left bottom;
    z-index:20;
    pointer-events:auto;
}
#mobileTopBar{
    display:none;
}
body.menu-active #mobileTopBar{
    opacity:0;
    pointer-events:none;
}
body.menu-active #cornerBest{
    opacity:0;
    pointer-events:none;
}
@media (max-width: 900px){
    #hud{
        display:none !important;
    }

    #mobileTopBar{
        position:absolute;
        top:max(4px, env(safe-area-inset-top));
        left:50%;
        transform:translateX(-50%);
        z-index:35;
        display:flex;
        gap:8px;
        background:rgba(0,0,0,0.62);
        border:1px solid rgba(255,122,0,0.45);
        box-shadow:0 0 16px rgba(255,122,0,0.45);
        border-radius:10px;
        padding:5px 8px;
        color:#ffb45c;
        font-size:12px;
        font-weight:700;
        text-shadow:0 0 10px rgba(255,122,0,0.6);
        pointer-events:none;
        align-items:flex-start;
    }
    #mobileTopBar .mobileStat{
        white-space:nowrap;
    }
    #topRankBlock{
        min-width:90px;
        display:flex;
        flex-direction:column;
        align-items:flex-end;
        gap:2px;
        color:#ffcf92;
    }
    #topRankProgressTrack{
        width:92px;
        height:4px;
        border-radius:999px;
        background:rgba(255,255,255,0.14);
        border:1px solid rgba(255,255,255,0.15);
        overflow:hidden;
    }
    #topRankProgressFill{
        width:0%;
        height:100%;
        border-radius:999px;
        background:#7CFC00;
        box-shadow:0 0 10px currentColor;
        transition:width 0.28s ease;
    }
    #topRankProgressText{
        font-size:10px;
        line-height:1;
        color:#ffd7a0;
    }
}
body.menu-active #keys,
body.menu-active #hud,
body.menu-active #exitBtn{
    opacity:0;
    pointer-events:none;
}
body.gameover-active #hud{
    opacity:1;
    pointer-events:auto;
}
@media (max-width: 900px){
    body.gameover-active #hud{
        opacity:0;
        pointer-events:none;
    }
}
body.menu-active canvas{
    filter:blur(2px) brightness(0.75);
}


.row{
    display:flex;
    gap:10px;
    margin-top:10px;
}
.center{
    justify-content:center;
}

.key{
    width:58px;
    height:58px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#111;
    border-radius:12px;
    color:white;
    font-size:26px;
    box-shadow:0 0 10px #ff7a00;
    transition:0.1s;
    touch-action:none;
}
#cornerBest{
    display:none;
    position:absolute;
    top:max(8px, env(safe-area-inset-top));
    left:max(8px, env(safe-area-inset-left));
    z-index:34;
    background:rgba(0,0,0,0.62);
    border:1px solid rgba(255,122,0,0.45);
    box-shadow:0 0 14px rgba(255,122,0,0.42);
    border-radius:10px;
    padding:4px 8px;
    color:#ffb45c;
    font-size:12px;
    font-weight:700;
    text-shadow:0 0 10px rgba(255,122,0,0.6);
    pointer-events:none;
}
@media (max-width: 900px){
    #cornerBest{
        display:block;
    }
}
@media (max-width: 900px), (max-height: 560px){
    .menu{
        width:min(94vw, 460px);
        padding:18px;
        max-height:min(90vh, 700px);
        border-radius:14px;
    }

    button{
        padding:9px 14px;
        font-size:15px;
    }

    #keys{
        bottom:max(10px, env(safe-area-inset-bottom));
        left:50%;
        transform:translateX(-50%) scale(var(--ui-scale));
        transform-origin:center bottom;
    }

    .row{
        gap:8px;
        margin-top:8px;
    }

    .key{
        width:56px;
        height:56px;
        border-radius:12px;
        font-size:24px;
        box-shadow:0 0 10px #ff7a00;
    }

    #hud{
        top:max(8px, env(safe-area-inset-top));
        left:50%;
        right:auto;
        transform:translateX(-50%) scale(var(--ui-scale));
        transform-origin:center top;
        flex-direction:row;
        flex-wrap:wrap;
        justify-content:center;
        width:min(96vw, 560px);
        gap:6px;
    }

    #scoreHudBox{
        order:1;
    }

    #speedHudBox{
        order:2;
    }

    .hudBox{
        padding:8px 9px;
        border-radius:10px;
        min-width:64px;
        box-shadow:0 0 14px #ff7a00;
    }

    .label{
        font-size:10px;
    }

    #liveScore,
    #bestScore,
    #levelDisplay,
    #mutationDisplay,
    #speedDisplay,
    #snakeLevelDisplay,
    #trophyCount,
    #coinCount,
    #rankDisplay{
        font-size:14px;
    }

    #exitBtn{
        top:max(8px, env(safe-area-inset-top));
        right:max(8px, env(safe-area-inset-right));
        padding:8px 12px;
        font-size:14px;
        transform:scale(var(--ui-scale));
        transform-origin:right top;
    }

    canvas{
        width:min(96vw, max(220px, calc(100svh - (230px * var(--ui-scale)))));
        height:min(96vw, max(220px, calc(100svh - (230px * var(--ui-scale)))));
    }
}
@media (max-width: 560px){
    #topRankBlock{
        min-width:78px;
    }
    #topRankProgressTrack{
        width:74px;
    }
    #topRankProgressText{
        font-size:9px;
    }
    canvas{
        width:min(96vw, max(180px, calc(100svh - (210px * var(--ui-scale)))));
        height:min(96vw, max(180px, calc(100svh - (210px * var(--ui-scale)))));
        border-radius:14px;
    }

    #hud{
        top:max(6px, env(safe-area-inset-top));
        width:calc(100vw - 12px);
        gap:5px;
    }

    #scoreHudBox,
    #speedHudBox{
        display:block;
    }

    .hudBox{
        padding:6px 8px;
        min-width:58px;
    }

    .label{
        font-size:9px;
        margin-bottom:3px;
    }

    #liveScore,
    #bestScore,
    #levelDisplay,
    #mutationDisplay,
    #speedDisplay,
    #snakeLevelDisplay,
    #trophyCount,
    #coinCount,
    #rankDisplay{
        font-size:12px;
    }

    #keys{
        bottom:max(8px, env(safe-area-inset-bottom));
    }

    .key{
        width:68px;
        height:68px;
        font-size:28px;
    }

    .skinRow,
    .shopRow{
        flex-direction:column;
        align-items:stretch;
        text-align:left;
        gap:6px;
    }

    .skinRow input,
    .skinRow select{
        min-width:100%;
    }
}
@media (orientation: portrait) and (max-width: 560px){
    #hud{
        top:max(6px, env(safe-area-inset-top));
        left:50%;
        right:auto;
        transform:translateX(-50%) scale(var(--ui-scale));
        transform-origin:center top;
        width:calc(100vw - 10px);
        flex-wrap:nowrap;
        justify-content:flex-start;
        overflow-x:auto;
        overflow-y:hidden;
        gap:5px;
        padding-bottom:2px;
    }

    .hudBox{
        flex:0 0 auto;
    }

    #scoreHudBox{
        order:1;
    }

    #speedHudBox{
        order:2;
    }

    #keys{
        left:50%;
        right:auto;
        transform:translateX(-50%) scale(var(--ui-scale));
        transform-origin:center bottom;
        bottom:max(10px, env(safe-area-inset-bottom));
    }

    canvas{
        width:min(96vw, max(180px, calc(100svh - (255px * var(--ui-scale)))));
        height:min(96vw, max(180px, calc(100svh - (255px * var(--ui-scale)))));
    }
}
@media (orientation: landscape) and (max-height: 560px){
    #hud{
        top:max(4px, env(safe-area-inset-top));
        left:max(4px, env(safe-area-inset-left));
        right:max(4px, env(safe-area-inset-right));
        width:auto;
        transform:none;
        transform-origin:left top;
        flex-wrap:nowrap;
        justify-content:flex-start;
        overflow-x:auto;
        overflow-y:hidden;
        padding-bottom:2px;
        gap:5px;
    }

    .hudBox{
        flex:0 0 auto;
    }

    #keys{
        left:50%;
        right:auto;
        transform:translateX(-50%) scale(var(--ui-scale));
        transform-origin:center bottom;
        bottom:max(4px, env(safe-area-inset-bottom));
    }

    canvas{
        width:min(92vw, max(190px, calc(100svh - (175px * var(--ui-scale)))));
        height:min(92vw, max(190px, calc(100svh - (175px * var(--ui-scale)))));
    }
}

#exitBtn{
    position:absolute;
    top:30px;
    right:30px;
    padding:10px 20px;
    border:none;
    border-radius:8px;
    cursor:pointer;
    background:#ff0040;
    color:white;
    transform:scale(var(--ui-scale));
    transform-origin:right top;
}
#hud{
    position:absolute;
    right:30px;
    top:50%;
    transform:translateY(-50%) scale(var(--ui-scale));
    transform-origin:right center;
    display:flex;
    flex-direction:column;
    gap:20px;
    z-index:20;
}

.hudBox{
    background:rgba(0,0,0,0.6);
    padding:20px 30px;
    border-radius:15px;
    text-align:center;
    box-shadow:0 0 25px #ff7a00;
}

.label{
    font-size:14px;
    color:#888;
    margin-bottom:5px;
}

.key.active{
    background:#ff7a00;
    color:black;
    box-shadow:0 0 25px #ff9d2f;
}

#liveScore,
#bestScore,
#levelDisplay,
#mutationDisplay,
#speedDisplay,
#snakeLevelDisplay,
#trophyCount,
#coinCount,
#rankDisplay{
    font-size:28px;
    color:#ff7a00;
text-shadow:0 0 15px #ff7a00;
}

#menuSnakeLevel,
#menuSnakeXp,
#menuSnakeXpNeed{
    color:#ffb347;
    text-shadow:0 0 10px rgba(255,122,0,0.55);
    font-weight:700;
}

#rankDisplay{
    font-size:24px;
    font-weight:bold;
    text-shadow:0 0 15px currentColor;
    transition: transform 0.3s ease;
}
#rankProgressTrack{
    width:100%;
    height:6px;
    margin-top:6px;
    border-radius:999px;
    background:rgba(255,255,255,0.12);
    border:1px solid rgba(255,255,255,0.16);
    overflow:hidden;
}
#rankProgressFill{
    width:0%;
    height:100%;
    border-radius:999px;
    background:#7CFC00;
    box-shadow:0 0 12px currentColor;
    transition:width 0.28s ease;
}
#rankProgressText{
    margin-top:4px;
    font-size:11px;
    color:#ffd7a0;
    text-shadow:0 0 10px rgba(255,122,0,0.45);
}
.menu h3{
    color:#fff;
    margin:8px 0 12px;
}
.menu p{
    color:#fff;
}
.challengeCard{
    background:rgba(255,122,0,0.12);
    border:1px solid rgba(255,122,0,0.45);
    border-radius:10px;
    padding:8px 10px;
    margin-top:8px;
    text-align:left;
}
.challengeTitle{
    color:#ffd7a0;
    font-size:13px;
}
.challengeProgress{
    color:#fff;
    font-size:14px;
    margin-top:3px;
}
#authPanel{
    margin:10px 0 12px;
    padding:10px;
    border-radius:10px;
    border:1px solid rgba(255,122,0,0.35);
    background:rgba(255,122,0,0.08);
}
#authStatus{
    color:#ffd9ab;
    font-size:13px;
    margin-bottom:8px;
}
.authRow{
    display:flex;
    gap:6px;
    margin:6px 0;
}
.authRow input{
    flex:1;
    min-width:0;
    padding:8px 10px;
    border-radius:8px;
    border:1px solid rgba(255,122,0,0.45);
    background:rgba(0,0,0,0.45);
    color:#fff;
}
.authRow button{
    margin:0;
    flex:1;
}
.authHelp{
    margin-top:10px;
    color:#ffd9ab;
    font-size:12px;
    line-height:1.35;
}
.authHelp a{
    color:#ffb45c;
}
.roomStatus{
    margin:8px 0 10px;
    color:#ffd9ab;
    font-size:13px;
    line-height:1.35;
    text-align:left;
}
#roomPlayers{
    margin-top:8px;
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,122,0,0.35);
    background:rgba(0,0,0,0.32);
    color:#fff;
    text-align:left;
    font-size:13px;
    line-height:1.35;
}
#roomLeaderControls{
    margin-top:8px;
}
#roomLeaderControls .authRow{
    margin:0;
}
#roomPublicList{
    margin-top:10px;
    max-height:180px;
    overflow:auto;
    text-align:left;
}
.roomPublicItem{
    border:1px solid rgba(255,122,0,0.3);
    border-radius:8px;
    padding:7px 8px;
    margin-bottom:6px;
    background:rgba(0,0,0,0.28);
    color:#fff;
    font-size:12px;
    line-height:1.3;
}
.roomPublicItem button{
    margin-top:6px;
    width:100%;
}
#roomResultText{
    color:#ffd9ab;
    min-height:20px;
}
.roomToast{
    position:fixed;
    top:max(14px, env(safe-area-inset-top));
    left:50%;
    transform:translateX(-50%) translateY(-16px) scale(0.96);
    z-index:100;
    opacity:0;
    pointer-events:none;
    background:linear-gradient(135deg, rgba(255,122,0,0.94), rgba(255,170,72,0.94));
    color:#1f0d00;
    border:1px solid rgba(255,228,188,0.95);
    border-radius:12px;
    padding:10px 14px;
    font-size:14px;
    font-weight:800;
    text-shadow:0 1px 0 rgba(255,255,255,0.35);
    box-shadow:
        0 0 0 1px rgba(0,0,0,0.2) inset,
        0 0 18px rgba(255,122,0,0.65),
        0 12px 26px rgba(0,0,0,0.38);
    transition:opacity 0.24s ease, transform 0.24s ease;
}
.roomToast.show{
    opacity:1;
    transform:translateX(-50%) translateY(0) scale(1);
}
.shopRow,
.skinRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin:8px 0;
    color:#fff;
}
.shopRow button,
.skinRow button{
    margin:0;
}
.skinRow input,
.skinRow select{
    min-width:140px;
}
.shopOwned{
    color:#7CFC00;
    font-size:12px;
}
.neonPresetWrap{
    margin-top:8px;
    color:#fff;
}
#mainMenu > button{
    display:block;
    width:100%;
    margin:8px 0;
}
#mainMenu .menuGroup{
    margin:6px 0 10px;
    padding:8px;
    border:1px solid rgba(255,122,0,0.35);
    border-radius:10px;
    background:rgba(255,122,0,0.08);
}
#mainMenu .menuGroup button{
    width:100%;
    margin:4px 0;
}
#mainMenu.submenu-open > button{
    display:none;
}
#mainMenu.submenu-open .menuGroup{
    display:none;
}
#mainMenu.submenu-play #playModes{
    display:block;
}
#mainMenu.submenu-settings #settingsPanel{
    display:block;
}
#mainMenu.submenu-open #mainMenuBackBtn{
    display:block;
    margin-top:14px;
}
body.extreme-compact .menu{
    padding:12px;
    border-radius:12px;
}
body.extreme-compact button{
    padding:7px 10px;
    font-size:13px;
    margin:4px 0;
}
body.extreme-compact #mainMenu > button{
    margin:5px 0;
}
body.extreme-compact .challengeCard{
    padding:6px 8px;
    margin-top:6px;
}
body.extreme-compact .challengeTitle{
    font-size:11px;
}
body.extreme-compact .challengeProgress{
    font-size:12px;
}
body.extreme-compact .hudBox[data-compact-hide="1"]{
    display:none;
}
body.extreme-compact #hud{
    gap:4px;
}
body.extreme-compact .hudBox{
    padding:5px 6px;
    min-width:52px;
}
body.extreme-compact .label{
    font-size:8px;
    margin-bottom:2px;
}
body.extreme-compact #liveScore,
body.extreme-compact #bestScore,
body.extreme-compact #levelDisplay,
body.extreme-compact #mutationDisplay,
body.extreme-compact #speedDisplay,
body.extreme-compact #snakeLevelDisplay,
body.extreme-compact #trophyCount,
body.extreme-compact #coinCount,
body.extreme-compact #rankDisplay{
    font-size:11px;
}
body.extreme-compact #scoreHudBox,
body.extreme-compact #speedHudBox{
    display:block;
}
body.extreme-compact #rankProgressTrack{
    height:4px;
    margin-top:4px;
}
body.extreme-compact #rankProgressText{
    margin-top:3px;
    font-size:9px;
}
body.hide-level-progression .hudBox[data-hide-ui="1"]{
    display:none;
}
#progressLine{
    display:none;
}
body.extreme-compact .key{
    width:60px;
    height:60px;
    border-radius:10px;
    font-size:24px;
}

</style>
</head>
<body>
<div id="cornerBest">Рекорд: <span id="cornerBestValue">0</span></div>
<div id="mobileTopBar">
    <div class="mobileStat">Счёт: <span id="topScore">0</span></div>
    <div class="mobileStat">Скорость: <span id="topSpeed">0</span></div>
    <div id="topRankBlock">
        <div><span id="topRank">1</span></div>
        <div id="topRankProgressTrack"><div id="topRankProgressFill"></div></div>
        <div id="topRankProgressText">0/50</div>
    </div>
</div>
<div id="keys">
    <div class="row center">
        <div class="key" id="keyUp">↑</div>
    </div>

    <div class="row">
        <div class="key" id="keyLeft">←</div>
        <div class="key" id="keyDown">↓</div>
        <div class="key" id="keyRight">→</div>
    </div>
</div>
<div id="hud">
    <div class="hudBox" data-compact-hide="1">
    <div class="label">РАНГ</div>
    <div id="rankDisplay">1</div>
    <div id="rankProgressTrack"><div id="rankProgressFill"></div></div>
    <div id="rankProgressText">0/50</div>
</div>
    <div class="hudBox">
    <div class="label">ТРОФЕИ</div>
    <div id="trophyCount">0</div>
</div>
    <div class="hudBox">
    <div class="label">МОНЕТЫ</div>
    <div id="coinCount">0</div>
</div>
    <div class="hudBox" id="scoreHudBox">
        <div class="label">СЧЁТ</div>
        <div id="liveScore">0</div>
    </div>
    <div class="hudBox" data-hide-ui="1">
    <div class="label">УРОВЕНЬ</div>
    <div id="levelDisplay">1</div>
</div>
    <div class="hudBox" id="speedHudBox">
    <div class="label">СКОРОСТЬ</div>
    <div id="speedDisplay">0</div>
</div>
    <div class="hudBox" data-compact-hide="1">
    <div class="label">МУТАЦИЯ</div>
    <div id="mutationDisplay">-</div>
</div>
    <div class="hudBox" data-compact-hide="1" data-hide-ui="1">
    <div class="label">ПРОКАЧКА</div>
    <div id="snakeLevelDisplay">1</div>
</div>
    <div class="hudBox" data-compact-hide="1">
        <div class="label">РЕКОРД</div>
        <div id="bestScore">0</div>
    </div>
</div>
<canvas id="game" width="720" height="720"></canvas>
<button id="exitBtn" class="hidden">В меню</button>
<div class="active" style="display:none;"></div>

<div class="menu" id="mainMenu">
    <p style="color:white;margin-top:15px;">
Трофеи: <span id="menuTrophies">0</span>
</p>
<p style="color:white;margin-top:6px;">
Монеты: <span id="menuCoins">0</span>
</p>
<h2 id="title">Neon Snake</h2>
<p id="progressLine" style="margin:8px 0 3px;">Прокачка змейки: lvl <span id="menuSnakeLevel">1</span> (<span id="menuSnakeXp">0</span>/<span id="menuSnakeXpNeed">10</span> XP)</p>
<div class="challengeCard">
    <div class="challengeTitle">Челлендж дня #1</div>
    <div class="challengeProgress" id="dailyChallengeA">-</div>
</div>
<div class="challengeCard">
    <div class="challengeTitle">Челлендж дня #2</div>
    <div class="challengeProgress" id="dailyChallengeB">-</div>
</div>
<button id="playGroupBtn">Играть</button>
<div id="playModes" class="menuGroup hidden">
    <button id="playBtn">Обычная игра</button>
    <button id="trainBtn">Тренировка</button>
    <button id="aiBtn">Смотреть AI (beta)</button>
    <button id="roomBtn">Онлайн комната</button>
</div>
<button id="settingsGroupBtn">Настройки</button>
<div id="settingsPanel" class="menuGroup hidden">
    <button id="historyBtn">История игр</button>
    <button id="accountBtn">Аккаунт</button>
    <button id="mainExportProgressBtn">Экспорт прогресса</button>
    <button id="mainImportProgressBtn">Импорт прогресса</button>
</div>
<button id="skinEditorBtn">Редактор эффектов</button>
<button id="shopBtn">Магазин эффектов</button>
<button id="mainMenuBackBtn" class="hidden">Назад</button>
</div>

<div class="menu hidden" id="gameOverMenu">
<h2>Игра окончена</h2>
<p>Счёт: <span id="finalScore"></span></p>
<p id="gameOverTrophies">Трофеи: <span id="gameOverTrophiesValue">0</span><span id="gameOverTrophiesDelta"></span></p>
<p id="roomResultText"></p>
<button id="restartBtn">Рестарт</button>
<button id="roomRematchBtn" class="hidden">Реванш в комнате</button>
<button id="roomLeaveBtn" class="hidden">Выйти из комнаты</button>
<button id="menuBtn">Главное меню</button>
</div>
<div class="menu hidden" id="historyMenu">
    <h2 style="color:white;">История игр</h2>
    <div id="historyList" style="
        max-height:300px;
        overflow-y:auto;
        text-align:left;
        margin-top:15px;
        color:white;
    "></div>
    <div id="historyActions">
        <button id="exportHistoryBtn">Экспорт</button>
        <button id="importHistoryBtn">Импорт</button>
        <input id="importHistoryInput" type="file" accept="application/json" class="hidden">
    </div>
    <button id="closeHistoryBtn">Закрыть</button>
</div>
<input id="importProgressInput" type="file" accept="application/json" class="hidden">
<div class="menu hidden" id="accountMenu">
    <h2 style="color:white;">Аккаунт</h2>
    <div id="authPanel">
        <div id="authStatus">Аккаунт: не выполнен вход</div>
    <div class="authRow" id="authFormRow">
        <input id="authEmail" type="text" placeholder="Email или ник">
        <input id="authPassword" type="password" placeholder="Пароль">
    </div>
    <div class="authRow" id="authNicknameRow">
        <input id="authNickname" type="text" placeholder="Ник (для регистрации)">
    </div>
    <div class="authRow" id="authGuestButtons">
        <button id="authLoginBtn">Войти</button>
        <button id="authRegisterBtn">Регистрация</button>
    </div>
        <div class="authRow hidden" id="authUserButtons">
            <input id="authNicknameEdit" type="text" placeholder="Новый ник">
            <button id="authUpdateNicknameBtn">Сменить ник</button>
            <button id="authSyncBtn">Синхронизировать</button>
            <button id="authLogoutBtn">Выйти</button>
        </div>
        <div class="authHelp">
            Хотите удалить аккаунт, задонатить монеты или обнаружили баг в игре? Пишите нам в телеграм:
            <a href="https://t.me/zmixl" target="_blank" rel="noopener noreferrer">@zmixl</a>
        </div>
    </div>
    <button id="closeAccountMenuBtn">Назад</button>
</div>
<div class="menu hidden" id="roomMenu">
    <h2 style="color:white;">Приватная комната</h2>
    <div id="roomStatusText" class="roomStatus">Войдите в аккаунт, чтобы играть онлайн.</div>
    <div class="authRow">
        <input id="roomCodeInput" type="text" maxlength="8" placeholder="Код комнаты">
        <button id="roomJoinBtn">Войти</button>
    </div>
    <div class="authRow">
        <button id="roomCreateBtn">Создать комнату</button>
        <button id="roomRefreshBtn">Обновить</button>
    </div>
    <div id="roomInfoWrap" class="hidden">
        <div id="roomPlayers"></div>
        <div id="roomLeaderControls" class="hidden">
            <div class="authRow">
                <input id="roomTargetInput" type="number" min="5" max="300" value="20" placeholder="Цель по счёту">
                <input id="roomSpeedInput" type="number" min="140" max="700" value="320" placeholder="Скорость">
            </div>
            <div class="authRow">
                <input id="roomMaxPlayersInput" type="number" min="2" max="8" value="2" placeholder="Игроков в комнате">
                <button id="roomSetTargetBtn">Сохранить настройки</button>
            </div>
            <div class="authRow">
                <label style="color:#ffd9ab;display:flex;align-items:center;gap:8px;font-size:13px;">
                    <input id="roomPublicInput" type="checkbox">
                    Публичная комната
                </label>
            </div>
            <button id="roomStartBtn">Старт челленджа</button>
            <button id="roomRematchMenuBtn">Перезапустить челлендж</button>
        </div>
        <button id="roomLeaveMenuBtn">Выйти из комнаты</button>
    </div>
    <h3 style="margin-top:12px;">Публичные комнаты</h3>
    <div class="authRow">
        <button id="roomPublicRefreshBtn">Обновить список</button>
    </div>
    <div id="roomPublicList"></div>
    <button id="closeRoomMenuBtn">Назад</button>
</div>
<div class="menu hidden" id="skinMenu">
    <h2 style="color:white;">Редактор эффектов</h2>
    <div class="skinRow">
        <label for="foodColorInput">Цвет еды</label>
        <input type="color" id="foodColorInput" value="#ff8e1a">
    </div>
    <div class="skinRow">
        <label for="foodTypeSelect">Тип еды</label>
        <select id="foodTypeSelect">
            <option value="solar">Solar</option>
            <option value="plasma">Plasma</option>
            <option value="toxic">Toxic</option>
            <option value="void">Void</option>
        </select>
    </div>
    <div class="skinRow">
        <label for="eatEffectSelect">Эффект поедания</label>
        <select id="eatEffectSelect">
            <option value="spark">Spark</option>
            <option value="burst">Burst</option>
            <option value="ring">Ring</option>
        </select>
    </div>
    <div class="neonPresetWrap">
        Неон-пакет:
        <button data-neon-pack="sunburst">Sunburst</button>
        <button data-neon-pack="arctic">Arctic</button>
        <button data-neon-pack="toxic">Toxic</button>
    </div>
    <button id="closeSkinMenuBtn">Назад</button>
</div>
<div class="menu hidden" id="shopMenu">
    <h2 style="color:white;">Магазин эффектов</h2>
    <p>Монеты: <span id="shopCoins">0</span></p>
    <div id="shopList"></div>
    <button id="closeShopBtn">Назад</button>
</div>
<div id="roomEventToast" class="roomToast"></div>

<script type="module">
import { initFoodRenderer, renderFood, setFoodRenderConfig } from "./foodRenderer.js";
import { initAI, runAI, resetAI } from "./ai.js";
import { initBackgroundRenderer, renderBackground } from "./backgroundRenderer.js";
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
initFoodRenderer(ctx);
initBackgroundRenderer(ctx, 720);
const size = 720;
const CELL = 20;
const GRID = size / CELL;

let aiTimer = 0;
let gameFrame = 0;
let currentReplayData = null;
let replayFoodIndex = 0;
let foodHistory = [];
let accumulator = 0;
const FIXED_STEP = 1000 / 120; // 120 симуляций в секунду
let isReplaying = false;
let gameStartTime = 0;
let gameHistory = JSON.parse(localStorage.getItem("gameHistory")) || [];
let trophies = parseInt(localStorage.getItem("trophies")) || 0;
let coins = parseInt(localStorage.getItem("coins")) || 0;
let rankRewardClaimedRank = parseInt(localStorage.getItem("rankRewardClaimedRank")) || 0;
setHudTrophiesValue(trophies);
setHudCoinsValue(coins);
const SHOP_ITEMS = [
    { id: "eat-burst", type: "eatEffect", title: "Эффект: Burst", price: 25, value: "burst" },
    { id: "eat-ring", type: "eatEffect", title: "Эффект: Ring", price: 40, value: "ring" },
    { id: "food-plasma", type: "foodType", title: "Еда: Plasma", price: 30, value: "plasma" },
    { id: "food-void", type: "foodType", title: "Еда: Void", price: 45, value: "void" },
    { id: "food-toxic", type: "foodType", title: "Еда: Toxic", price: 50, value: "toxic" }
];
const NEON_PACKS = {
    sunburst: {
        foodColor: "#ff9e2f",
        foodGlow: "#ff7a00",
        particleColor: "#ffd27a",
        neonBoost: 1.05
    },
    arctic: {
        foodColor: "#58d7ff",
        foodGlow: "#37d5ff",
        particleColor: "#b7f5ff",
        neonBoost: 1.2
    },
    toxic: {
        foodColor: "#a7ff31",
        foodGlow: "#78ff00",
        particleColor: "#d4ff93",
        neonBoost: 1.15
    }
};
const defaultCosmetics = {
    foodColor: "#ff8e1a",
    foodGlow: "#ff7a00",
    particleColor: "#ffd27a",
    neonBoost: 1,
    eatEffect: "spark",
    foodType: "solar",
    unlocked: ["classic"]
};
const defaultSnakeProgress = {
    level: 1,
    xp: 0,
    xpNeed: 10
};
let snakeProgress = (() => {
    try {
        const parsed = JSON.parse(localStorage.getItem("snakeProgress") || "{}");
        return {
            level: Number.isFinite(parsed.level) ? Math.max(1, parsed.level) : 1,
            xp: Number.isFinite(parsed.xp) ? Math.max(0, parsed.xp) : 0,
            xpNeed: Number.isFinite(parsed.xpNeed) ? Math.max(5, parsed.xpNeed) : 10
        };
    } catch (e) {
        return { ...defaultSnakeProgress };
    }
})();
let cosmetics = (() => {
    try {
        const parsed = JSON.parse(localStorage.getItem("cosmetics") || "{}");
        const unlocked = Array.isArray(parsed.unlocked) ? parsed.unlocked : [];
        return {
            ...defaultCosmetics,
            ...parsed,
            unlocked: Array.from(new Set(["classic", ...unlocked]))
        };
    } catch (e) {
        return { ...defaultCosmetics };
    }
})();
let dailyChallenges = buildDailyChallenges();
let survivalMsCurrentRun = 0;
let eatFx = [];
const MUTATIONS = [
    { id: "phase", name: "Фаза", durationMs: 9000 },
    { id: "magnet", name: "Магнит", durationMs: 11000 },
    { id: "overdrive", name: "Овердрайв", durationMs: 8500 }
];
let activeMutation = null;
let aiInterval = 22; // миллисекунды
let snake, dir, food;
let pendingPlayerDir = null;
let trophyAnimationFrame = 0;
let trophyAnimationStartTimeout = 0;
let stateFrames = [];
let currentReplay = [];
let hamiltonianPath = buildHamiltonianPath();
initAI(hamiltonianPath, CELL);
let deathCount = 0;
let score=0;
let replaySeed = 0;
let level = 1;
let running=false;
let lastTime=0;
let targetLength=120;
let aiMode=false;
 let baseSpeed = 350;
let speed = baseSpeed;
let sessionStartSpeed = baseSpeed;
let sessionStartTargetLength = 120;
let sessionStartDir = {x:1, y:0};
let sessionStartTrophies = trophies;
let sessionUsedAI = false;
let sessionNoRewards = false;
let best = localStorage.getItem("best") || 0;
updateBestDisplay();
gameHistory = Array.isArray(gameHistory)
    ? gameHistory.map((item) => normalizeHistoryRecord(item, !!item?.imported)).filter(Boolean).slice(0, 50)
    : [];
persistHistory();
function init(){
    snake = [{x:360, y:360}];
    dir = {x:1, y:0};
    pendingPlayerDir = null;
    food = randomFood();
    score = 0;
    level = 1;
    survivalMsCurrentRun = 0;
    eatFx = [];
    clearMutation();
    speed = baseSpeed;
    targetLength = 120;
    updateScoreDisplay();
    document.getElementById("levelDisplay").innerText = level;
    updateSpeedByTrophies();
    updateSpeedDisplay();
}
function seededRandom() {
    replaySeed = (replaySeed * 1664525 + 1013904223) % 4294967296;
    return replaySeed / 4294967296;
}
const RANK_TIER_COLORS = [
    "#7CFC00",
    "#4cd7ff",
    "#ff7a00",
    "#ff4da6",
    "#b36bff",
    "#ff3b3b",
    "#00e6b8",
    "#ffd24d",
    "#5fa8ff",
    "#ffffff"
];

function getRankNumberFromTrophies(value) {
    const safe = Math.max(0, Math.floor(value));
    return Math.min(50, Math.floor(safe / 50) + 1);
}

function getRankData(){
    const rankNumber = getRankNumberFromTrophies(trophies);
    const tier = Math.min(RANK_TIER_COLORS.length - 1, Math.floor((rankNumber - 1) / 5));
    return {
        rankNumber,
        name: String(rankNumber),
        color: RANK_TIER_COLORS[tier]
    };
}

function getRankProgressData() {
    const safeTrophies = Math.max(0, Math.floor(trophies));
    const rankNumber = getRankNumberFromTrophies(safeTrophies);
    const maxRank = 50;
    const trophiesPerRank = 50;
    if (rankNumber >= maxRank) {
        return {
            percent: 100,
            label: "MAX",
            mobileLabel: "MAX"
        };
    }

    const rankStart = (rankNumber - 1) * trophiesPerRank;
    const inRank = Math.max(0, safeTrophies - rankStart);
    const clampedInRank = Math.min(trophiesPerRank, inRank);
    const remaining = Math.max(0, trophiesPerRank - clampedInRank);
    return {
        percent: (clampedInRank / trophiesPerRank) * 100,
        label: `${clampedInRank}/${trophiesPerRank} • до ${rankNumber + 1}: ${remaining}`,
        mobileLabel: `${clampedInRank}/${trophiesPerRank}`
    };
}

let currentRankName = getRankData().name;
function updateRank(){

    const rank = getRankData();
    const progress = getRankProgressData();
    const el = document.getElementById("rankDisplay");
    const topRank = document.getElementById("topRank");
    const rankProgressFill = document.getElementById("rankProgressFill");
    const rankProgressText = document.getElementById("rankProgressText");
    const topRankProgressFill = document.getElementById("topRankProgressFill");
    const topRankProgressText = document.getElementById("topRankProgressText");

    if(rank.name !== currentRankName){
        el.style.transform = "scale(1.3)";
        setTimeout(()=> el.style.transform="scale(1)", 300);
    }

    currentRankName = rank.name;

    let rewarded = false;
    while (rankRewardClaimedRank + 5 <= rank.rankNumber && rankRewardClaimedRank < 50) {
        rankRewardClaimedRank += 5;
        coins += rankRewardClaimedRank;
        rewarded = true;
    }
    if (rewarded) {
        localStorage.setItem("rankRewardClaimedRank", String(rankRewardClaimedRank));
        localStorage.setItem("coins", String(coins));
        setHudCoinsValue(coins);
        updateMenuTrophies();
    }

    el.innerText = rank.name;
    el.style.color = rank.color;
    if (rankProgressFill) {
        rankProgressFill.style.width = `${progress.percent}%`;
        rankProgressFill.style.color = rank.color;
    }
    if (rankProgressText) {
        rankProgressText.innerText = progress.label;
    }
    if (topRank) {
        topRank.innerText = rank.name;
        topRank.style.color = rank.color;
    }
    if (topRankProgressFill) {
        topRankProgressFill.style.width = `${progress.percent}%`;
        topRankProgressFill.style.color = rank.color;
    }
    if (topRankProgressText) {
        topRankProgressText.innerText = progress.mobileLabel;
    }
}

function updateBestDisplay() {
    const bestEl = document.getElementById("bestScore");
    if (bestEl) bestEl.innerText = String(best);
    const corner = document.getElementById("cornerBestValue");
    if (corner) corner.innerText = String(best);
}

function updateMenuTrophies(){
    document.getElementById("menuTrophies").innerText = trophies;
    const menuCoins = document.getElementById("menuCoins");
    if (menuCoins) {
        menuCoins.innerText = coins;
    }
    const shopCoins = document.getElementById("shopCoins");
    if (shopCoins) {
        shopCoins.innerText = coins;
    }
}
updateMenuTrophies();

const ACCOUNT_TOKEN_KEY = "snakeAuthToken";
let accountToken = localStorage.getItem(ACCOUNT_TOKEN_KEY) || "";
let accountUser = null;
let cloudSyncTimer = 0;
let cloudSyncInFlight = false;
let cloudAutoSyncInterval = 0;
let lastKnownCloudUpdatedAtMs = 0;
let lastSyncedProgressJson = "";
let roomState = null;
let roomPollTimer = 0;
let roomLastStartedChallengeId = 0;
let roomScorePostTimer = 0;
let roomLastPostedScore = -1;
let roomLastDeathSeenAtMs = 0;
let roomToastTimer = 0;
let publicRooms = [];
let roomSession = {
    active: false,
    roomCode: "",
    challengeId: 0
};

function getProgressSnapshot() {
    return {
        trophies,
        coins,
        rankRewardClaimedRank,
        best,
        snakeProgress,
        cosmetics,
        dailyChallenges,
        gameHistory
    };
}

function getProgressSnapshotJson() {
    try {
        return JSON.stringify(getProgressSnapshot());
    } catch (_) {
        return "";
    }
}

function parseUpdatedAtMs(value) {
    if (!value) return 0;
    const ms = Date.parse(value);
    return Number.isFinite(ms) ? ms : 0;
}

function progressHasMeaningfulData(cloud) {
    if (!cloud || typeof cloud !== "object") return false;
    return (
        Number.isFinite(cloud.trophies) ||
        Number.isFinite(cloud.coins) ||
        Number.isFinite(cloud.best) ||
        (cloud.snakeProgress && typeof cloud.snakeProgress === "object") ||
        (cloud.cosmetics && typeof cloud.cosmetics === "object") ||
        (cloud.dailyChallenges && typeof cloud.dailyChallenges === "object") ||
        Array.isArray(cloud.gameHistory)
    );
}

async function apiRequest(path, options = {}) {
    const headers = {
        "Content-Type": "application/json",
        ...(options.headers || {})
    };
    if (accountToken) {
        headers.Authorization = `Bearer ${accountToken}`;
    }
    const response = await fetch(`/api/${path}`, {
        method: options.method || "GET",
        headers,
        body: options.body ? JSON.stringify(options.body) : undefined
    });
    let data = {};
    try {
        data = await response.json();
    } catch (_) {
        data = {};
    }
    if (!response.ok) {
        const err = new Error(data.error || `http_${response.status}`);
        err.code = data.error || `http_${response.status}`;
        err.detail = data.detail || "";
        throw err;
    }
    return data;
}

function renderAuthState(statusText = "") {
    const statusEl = document.getElementById("authStatus");
    const guestButtons = document.getElementById("authGuestButtons");
    const userButtons = document.getElementById("authUserButtons");
    const formRow = document.getElementById("authFormRow");
    const nickRow = document.getElementById("authNicknameRow");
    const nickEditInput = document.getElementById("authNicknameEdit");
    const base = accountUser
        ? `Аккаунт: ${accountUser.nickname || "без_ника"} (${accountUser.email})`
        : "Аккаунт: не выполнен вход";
    statusEl.innerText = statusText ? `${base} • ${statusText}` : base;
    guestButtons.classList.toggle("hidden", !!accountUser);
    formRow.classList.toggle("hidden", !!accountUser);
    nickRow.classList.toggle("hidden", !!accountUser);
    if (accountUser && nickEditInput) {
        nickEditInput.value = accountUser.nickname || "";
    }
    userButtons.classList.toggle("hidden", !accountUser);
}

function setAccountToken(token) {
    accountToken = token || "";
    if (accountToken) {
        localStorage.setItem(ACCOUNT_TOKEN_KEY, accountToken);
    } else {
        localStorage.removeItem(ACCOUNT_TOKEN_KEY);
    }
}

function logoutAccount(withMessage = true) {
    if (cloudSyncTimer) {
        clearTimeout(cloudSyncTimer);
        cloudSyncTimer = 0;
    }
    if (cloudAutoSyncInterval) {
        clearInterval(cloudAutoSyncInterval);
        cloudAutoSyncInterval = 0;
    }
    lastKnownCloudUpdatedAtMs = 0;
    lastSyncedProgressJson = "";
    applyRoomState(null);
    stopRoomPolling();
    publicRooms = [];
    setAccountToken("");
    accountUser = null;
    renderAuthState(withMessage ? "выход выполнен" : "");
    refreshRoomUI();
}

async function loadCloudProgress() {
    if (!accountToken || !accountUser) return;
    const data = await apiRequest("progress-get");
    const cloud = data && data.progress && typeof data.progress === "object" ? data.progress : null;
    lastKnownCloudUpdatedAtMs = Math.max(lastKnownCloudUpdatedAtMs, parseUpdatedAtMs(data.updatedAt));
    if (progressHasMeaningfulData(cloud)) {
        applyImportedProgress(cloud);
        lastSyncedProgressJson = getProgressSnapshotJson();
        return;
    }
    await syncCloudProgressNow(true);
}

async function syncCloudProgressNow(silent = false) {
    if (!accountToken || !accountUser || cloudSyncInFlight) return;
    cloudSyncInFlight = true;
    try {
        const payload = getProgressSnapshot();
        const result = await apiRequest("progress-save", {
            method: "POST",
            body: { progress: payload }
        });
        lastKnownCloudUpdatedAtMs = Math.max(lastKnownCloudUpdatedAtMs, parseUpdatedAtMs(result.updatedAt));
        lastSyncedProgressJson = getProgressSnapshotJson();
        if (!silent) {
            renderAuthState("синхронизировано");
        }
    } catch (error) {
        if ((error && error.message === "invalid_token") || (error && error.message === "user_not_found")) {
            logoutAccount(false);
            return;
        }
        if (!silent) {
            renderAuthState("ошибка синхронизации");
        }
        console.error(error);
    } finally {
        cloudSyncInFlight = false;
    }
}

async function pullCloudIfRemoteIsNewer() {
    if (!accountToken || !accountUser || cloudSyncInFlight) return;
    const data = await apiRequest("progress-get");
    const remoteMs = parseUpdatedAtMs(data.updatedAt);
    if (remoteMs <= 0 || remoteMs <= lastKnownCloudUpdatedAtMs) return;

    const cloud = data && data.progress && typeof data.progress === "object" ? data.progress : null;
    if (!progressHasMeaningfulData(cloud)) {
        lastKnownCloudUpdatedAtMs = remoteMs;
        return;
    }

    applyImportedProgress(cloud);
    lastKnownCloudUpdatedAtMs = remoteMs;
    lastSyncedProgressJson = getProgressSnapshotJson();
    renderAuthState("получены изменения из облака");
}

function startAutoCloudSyncLoop() {
    if (cloudAutoSyncInterval) {
        clearInterval(cloudAutoSyncInterval);
    }
    cloudAutoSyncInterval = setInterval(async () => {
        if (!accountToken || !accountUser || cloudSyncInFlight) return;
        try {
            await pullCloudIfRemoteIsNewer();
            const currentJson = getProgressSnapshotJson();
            if (currentJson && currentJson !== lastSyncedProgressJson) {
                await syncCloudProgressNow(true);
            }
        } catch (error) {
            console.error(error);
        }
    }, 12000);
}

function scheduleCloudSync(delayMs = 600) {
    if (!accountToken || !accountUser) return;
    if (cloudSyncTimer) {
        clearTimeout(cloudSyncTimer);
    }
    cloudSyncTimer = setTimeout(() => {
        cloudSyncTimer = 0;
        const currentJson = getProgressSnapshotJson();
        if (currentJson && currentJson === lastSyncedProgressJson) return;
        syncCloudProgressNow();
    }, delayMs);
}

async function loginOrRegister(action) {
    const identifier = document.getElementById("authEmail").value.trim();
    const email = identifier.toLowerCase();
    const password = document.getElementById("authPassword").value;
    const nickname = document.getElementById("authNickname").value.trim();
    if (!identifier || !password) {
        renderAuthState("введите email/ник и пароль");
        return;
    }
    if (action === "auth-register" && nickname.length < 3) {
        renderAuthState("ник минимум 3 символа");
        return;
    }
    try {
        renderAuthState(action === "auth-login" ? "вход..." : "регистрация...");
        const data = await apiRequest(action, {
            method: "POST",
            body: action === "auth-login"
                ? { identifier: email, password }
                : { email, password, nickname }
        });
        setAccountToken(data.token || "");
        accountUser = data.user || null;
        if (action === "auth-register") {
            grantRegistrationFoodSkin();
        }
        renderAuthState("загрузка прогресса...");
        await loadCloudProgress();
        await restoreCurrentRoomState(false);
        await refreshPublicRoomsList();
        renderAuthState(action === "auth-register" ? "онлайн • бесплатный скин выдан" : "онлайн");
        startAutoCloudSyncLoop();
    } catch (error) {
        const detail = error && error.detail ? String(error.detail) : "";
        renderAuthState(detail ? `ошибка: ${detail}` : "ошибка авторизации");
        console.error(error);
    }
}

function grantRegistrationFoodSkin() {
    const rewardSkinId = "food-plasma";
    if (!Array.isArray(cosmetics.unlocked)) {
        cosmetics.unlocked = ["classic"];
    }
    if (!cosmetics.unlocked.includes(rewardSkinId)) {
        cosmetics.unlocked.push(rewardSkinId);
    }
    if (cosmetics.foodType === "solar") {
        cosmetics.foodType = "plasma";
    }
    saveCosmetics();
    applyCosmetics();
    syncSkinInputs();
}

async function updateNickname() {
    if (!accountUser) return;
    const nickname = document.getElementById("authNicknameEdit").value.trim();
    if (nickname.length < 3) {
        renderAuthState("ник минимум 3 символа");
        return;
    }
    try {
        renderAuthState("обновление ника...");
        const data = await apiRequest("auth-update-nickname", {
            method: "POST",
            body: { nickname }
        });
        accountUser = data.user || accountUser;
        renderAuthState("ник обновлён");
    } catch (error) {
        const detail = error && error.detail ? String(error.detail) : "";
        renderAuthState(detail ? `ошибка: ${detail}` : "ошибка обновления ника");
        console.error(error);
    }
}


async function bootstrapAccount() {
    if (!accountToken) {
        renderAuthState();
        refreshRoomUI();
        return;
    }
    try {
        const me = await apiRequest("auth-me");
        accountUser = me.user || null;
        renderAuthState("онлайн");
        await restoreCurrentRoomState(false);
        await refreshPublicRoomsList();
        await loadCloudProgress();
        startAutoCloudSyncLoop();
    } catch (error) {
        console.error(error);
        logoutAccount(false);
        refreshRoomUI();
    }
}

function getPlayerDisplayName(player) {
    if (!player) return "Игрок";
    return player.nickname || player.email || `Игрок ${player.userId || ""}`.trim();
}

function setRoomStatus(text) {
    const el = document.getElementById("roomStatusText");
    if (el) el.innerText = text || "";
}

function renderPublicRoomsList() {
    const listEl = document.getElementById("roomPublicList");
    if (!listEl) return;
    if (!accountUser || !accountToken) {
        listEl.innerHTML = '<div class="roomPublicItem">Нужен вход в аккаунт.</div>';
        return;
    }
    if (!publicRooms.length) {
        listEl.innerHTML = '<div class="roomPublicItem">Публичных комнат нет.</div>';
        return;
    }

    listEl.innerHTML = "";
    for (const room of publicRooms) {
        const div = document.createElement("div");
        div.className = "roomPublicItem";
        div.innerHTML = `Код: ${room.roomCode}<br>Лидер: ${room.leaderName}<br>Игроки: ${room.playersCount}/${room.maxPlayers}<br>Цель: ${room.targetScore} • Скорость: ${room.snakeSpeed}`;
        const btn = document.createElement("button");
        btn.innerText = "Войти в комнату";
        btn.disabled = room.playersCount >= room.maxPlayers;
        btn.addEventListener("click", async () => {
            try {
                const data = await apiRequest("room-join", {
                    method: "POST",
                    body: { roomCode: room.roomCode }
                });
                applyRoomState(data.room || null);
                roomLastStartedChallengeId = roomState ? Number(roomState.challengeId || 0) : 0;
                startRoomPolling();
                setRoomStatus("Вы вошли в публичную комнату.");
            } catch (error) {
                const msg = error && error.code ? error.code : "ошибка входа";
                setRoomStatus(`Ошибка: ${msg}`);
                console.error(error);
            }
        });
        div.appendChild(btn);
        listEl.appendChild(div);
    }
}

async function refreshPublicRoomsList() {
    if (!accountUser || !accountToken) {
        publicRooms = [];
        renderPublicRoomsList();
        return;
    }
    try {
        const data = await apiRequest("room-public-list", { method: "GET" });
        publicRooms = Array.isArray(data?.rooms) ? data.rooms : [];
    } catch (error) {
        console.error(error);
        publicRooms = [];
    }
    renderPublicRoomsList();
}

function parseIsoMs(value) {
    if (!value) return 0;
    const ms = Date.parse(value);
    return Number.isFinite(ms) ? ms : 0;
}

function showRoomEventToast(text) {
    const el = document.getElementById("roomEventToast");
    if (!el) return;
    if (roomToastTimer) {
        clearTimeout(roomToastTimer);
        roomToastTimer = 0;
    }
    el.innerText = text;
    el.classList.add("show");
    roomToastTimer = setTimeout(() => {
        el.classList.remove("show");
        roomToastTimer = 0;
    }, 2200);
}

function inRoomChallengeSession() {
    return !!roomSession.active && !!roomSession.roomCode;
}

function getRoomConfiguredSpeed() {
    if (!roomState) return 320;
    const parsed = Number.parseInt(roomState.snakeSpeed, 10);
    if (!Number.isFinite(parsed)) return 320;
    return Math.max(140, Math.min(700, parsed));
}

function stopRoomPolling() {
    if (roomPollTimer) {
        clearInterval(roomPollTimer);
        roomPollTimer = 0;
    }
}

function resetRoomSessionFlags() {
    roomScorePostTimer = 0;
    roomLastPostedScore = -1;
}

function refreshRoomUI() {
    const infoWrap = document.getElementById("roomInfoWrap");
    const playersEl = document.getElementById("roomPlayers");
    const leaderControls = document.getElementById("roomLeaderControls");
    const targetInput = document.getElementById("roomTargetInput");
    const speedInput = document.getElementById("roomSpeedInput");
    const maxPlayersInput = document.getElementById("roomMaxPlayersInput");
    const publicInput = document.getElementById("roomPublicInput");
    const roomCodeInput = document.getElementById("roomCodeInput");
    const roomStartBtn = document.getElementById("roomStartBtn");
    const roomRematchBtn = document.getElementById("roomRematchMenuBtn");

    if (!accountUser || !accountToken) {
        if (infoWrap) infoWrap.classList.add("hidden");
        if (leaderControls) leaderControls.classList.add("hidden");
        if (playersEl) playersEl.innerText = "";
        setRoomStatus("Войдите в аккаунт, чтобы играть онлайн.");
        renderPublicRoomsList();
        return;
    }

    if (!roomState) {
        if (infoWrap) infoWrap.classList.add("hidden");
        if (leaderControls) leaderControls.classList.add("hidden");
        if (playersEl) playersEl.innerText = "";
        setRoomStatus("Создайте комнату или войдите по коду.");
        renderPublicRoomsList();
        return;
    }

    const players = Array.isArray(roomState.players) ? roomState.players : [];
    const me = players.find((p) => Number(p.userId) === Number(accountUser.id)) || null;
    const occupancy = `${players.length}/${Math.max(2, Number(roomState.maxPlayers || 2))}`;
    const leader = players.find((p) => Number(p.userId) === Number(roomState.leaderUserId)) || null;
    const winner = players.find((p) => Number(p.userId) === Number(roomState.winnerUserId)) || null;
    const isLeader = !!me && Number(roomState.leaderUserId) === Number(accountUser.id);

    if (infoWrap) infoWrap.classList.remove("hidden");
    if (leaderControls) leaderControls.classList.toggle("hidden", !isLeader);
    const activeEl = document.activeElement;
    if (targetInput && Number.isFinite(Number(roomState.targetScore)) && activeEl !== targetInput) {
        targetInput.value = String(roomState.targetScore);
    }
    if (speedInput && Number.isFinite(Number(roomState.snakeSpeed)) && activeEl !== speedInput) {
        speedInput.value = String(roomState.snakeSpeed);
    }
    if (maxPlayersInput && Number.isFinite(Number(roomState.maxPlayers)) && activeEl !== maxPlayersInput) {
        maxPlayersInput.value = String(roomState.maxPlayers);
    }
    if (publicInput) {
        publicInput.checked = !!roomState.isPublic;
    }
    if (roomCodeInput && roomState.roomCode) {
        roomCodeInput.value = roomState.roomCode;
    }

    const playersLines = players.map((p) => {
        const role = Number(p.userId) === Number(roomState.leaderUserId) ? " [Лидер]" : "";
        const finishMark = p.runFinished ? " (финиш)" : "";
        return `${p.slot}. ${getPlayerDisplayName(p)} — ${p.score}${finishMark}${role}`;
    });

    if (playersEl) {
        playersEl.innerText = [
            `Комната: ${roomState.roomCode}`,
            `Участники: ${occupancy}`,
            `Цель: ${roomState.targetScore}`,
            `Скорость: ${roomState.snakeSpeed}`,
            `Тип: ${roomState.isPublic ? "публичная" : "приватная"}`,
            `Статус: ${roomState.status}`,
            ...playersLines
        ].join("\n");
    }

    if (roomStartBtn) {
        roomStartBtn.disabled = !isLeader || players.length !== Number(roomState.maxPlayers || 2) || roomState.status === "active";
    }
    if (roomRematchBtn) {
        roomRematchBtn.disabled = !isLeader || roomState.status === "active";
    }

    if (roomState.status === "finished") {
        if (winner) {
            setRoomStatus(`Челлендж завершен. Победил: ${getPlayerDisplayName(winner)}.`);
        } else {
            setRoomStatus("Челлендж завершен без победителя. Запустите новый.");
        }
    } else if (roomState.status === "active") {
        setRoomStatus(`Челлендж идет. Цель: ${roomState.targetScore}.`);
    } else {
        setRoomStatus(`Лидер: ${getPlayerDisplayName(leader)}. Ожидание старта.`);
    }
    renderPublicRoomsList();
}

function applyRoomState(nextRoom, options = {}) {
    const suppressEvents = !!options.suppressEvents;
    const prevRoom = roomState && typeof roomState === "object" ? roomState : null;
    roomState = nextRoom && typeof nextRoom === "object" ? nextRoom : null;
    if (!roomState) {
        roomSession = { active: false, roomCode: "", challengeId: 0 };
        stopRoomPolling();
        roomLastDeathSeenAtMs = 0;
    } else if (accountUser && accountToken) {
        startRoomPolling();
        const deathMs = parseIsoMs(roomState.lastDeathAt);
        if (!suppressEvents && deathMs > roomLastDeathSeenAtMs) {
            const players = Array.isArray(roomState.players) ? roomState.players : [];
            const dead = players.find((p) => Number(p.userId) === Number(roomState.lastDeathUserId)) || null;
            if (dead) {
                showRoomEventToast(`Выбыл: ${getPlayerDisplayName(dead)}`);
            }
        }
        roomLastDeathSeenAtMs = Math.max(roomLastDeathSeenAtMs, deathMs);
        if (!suppressEvents && prevRoom && prevRoom.status !== "finished" && roomState.status === "finished") {
            const text = getRoomWinnerText(roomState);
            if (text) showRoomEventToast(text);
        }
    }
    refreshRoomUI();
}

async function restoreCurrentRoomState(showStatus = false) {
    if (!accountUser || !accountToken) {
        applyRoomState(null);
        return null;
    }
    try {
        const data = await apiRequest("room-current", { method: "GET" });
        const nextRoom = data && data.room ? data.room : null;
        applyRoomState(nextRoom, { suppressEvents: true });
        if (showStatus) {
            if (nextRoom) {
                setRoomStatus(`Комната восстановлена: ${nextRoom.roomCode}`);
            } else {
                setRoomStatus("Вы не состоите в активной комнате.");
            }
        }
        return nextRoom;
    } catch (error) {
        console.error(error);
        if (showStatus) {
            setRoomStatus("Не удалось восстановить комнату.");
        }
        return null;
    }
}

function getRoomWinnerText(room) {
    if (!room || room.status !== "finished") return "";
    const players = Array.isArray(room.players) ? room.players : [];
    const winner = players.find((p) => Number(p.userId) === Number(room.winnerUserId)) || null;
    if (!winner) return "Челлендж завершён без победителя.";
    const winnerName = getPlayerDisplayName(winner);
    if (accountUser && Number(winner.userId) === Number(accountUser.id)) return `Победил: ${winnerName} (это вы).`;
    return `Победил: ${winnerName}.`;
}

async function sendRoomScore(scoreValue, isFinal = false) {
    if (!inRoomChallengeSession() || !roomState || !accountUser) return;
    const now = performance.now();
    if (!isFinal && roomScorePostTimer && now - roomScorePostTimer < 260) return;
    if (!isFinal && scoreValue <= roomLastPostedScore) return;

    roomScorePostTimer = now;
    roomLastPostedScore = Math.max(roomLastPostedScore, scoreValue);
    try {
        const data = await apiRequest("room-score", {
            method: "POST",
            body: {
                roomCode: roomSession.roomCode,
                score: scoreValue,
                isFinal
            }
        });
        if (data && data.room) {
            applyRoomState(data.room);
            if (running && roomState && roomState.status === "finished") {
                gameOver();
            }
        }
    } catch (error) {
        console.error(error);
    }
}

async function pullRoomState(force = false) {
    if (!accountUser || !accountToken || !roomState || !roomState.roomCode) return;
    try {
        const data = await apiRequest(`room-state?code=${encodeURIComponent(roomState.roomCode)}`, {
            method: "GET"
        });
        if (!data || !data.room) return;

        const prevChallenge = roomState.challengeId || 0;
        applyRoomState(data.room);

        if (!running && !isReplaying && roomState.status === "active") {
            if (force || roomState.challengeId !== roomLastStartedChallengeId || roomState.challengeId !== prevChallenge) {
                roomLastStartedChallengeId = roomState.challengeId;
                roomSession = {
                    active: true,
                    roomCode: roomState.roomCode,
                    challengeId: roomState.challengeId
                };
                resetRoomSessionFlags();
                document.getElementById("roomMenu").classList.add("hidden");
                startGame(false, true);
            }
        }

        if (roomState.status === "finished" && inRoomChallengeSession()) {
            const roomText = getRoomWinnerText(roomState);
            const roomResultEl = document.getElementById("roomResultText");
            if (roomResultEl) roomResultEl.innerText = roomText;
            if (running) {
                gameOver();
            }
        }
    } catch (error) {
        console.error(error);
    }
}

function startRoomPolling() {
    if (!roomState || !roomState.roomCode || !accountUser || roomPollTimer) return;
    roomPollTimer = setInterval(() => {
        pullRoomState(false);
    }, 1000);
}

function updateGameOverRoomControls() {
    const roomResultEl = document.getElementById("roomResultText");
    const restartBtn = document.getElementById("restartBtn");
    const roomRematchBtn = document.getElementById("roomRematchBtn");
    const roomLeaveBtn = document.getElementById("roomLeaveBtn");
    const menuBtn = document.getElementById("menuBtn");

    if (!inRoomChallengeSession()) {
        if (roomResultEl) roomResultEl.innerText = "";
        restartBtn.classList.remove("hidden");
        restartBtn.innerText = "Рестарт";
        roomRematchBtn.classList.add("hidden");
        roomLeaveBtn.classList.add("hidden");
        menuBtn.innerText = "Главное меню";
        return;
    }

    const isFinished = !!roomState && roomState.status === "finished";
    const isLeader = !!accountUser && Number(roomState?.leaderUserId) === Number(accountUser.id);
    restartBtn.classList.toggle("hidden", isFinished);
    restartBtn.innerText = "Ещё попытка";
    roomRematchBtn.classList.toggle("hidden", !isFinished || !isLeader);
    roomLeaveBtn.classList.remove("hidden");
    menuBtn.innerText = "В комнату";
    if (roomResultEl) {
        if (isFinished) {
            roomResultEl.innerText = getRoomWinnerText(roomState) || "Матч комнаты завершён.";
        } else {
            const target = roomState && Number.isFinite(Number(roomState.targetScore))
                ? Number(roomState.targetScore)
                : 20;
            roomResultEl.innerText = `Челлендж продолжается. Цель: ${target}.`;
        }
    }
}

function stopTrophyAnimation() {
    if (trophyAnimationStartTimeout) {
        clearTimeout(trophyAnimationStartTimeout);
        trophyAnimationStartTimeout = 0;
    }
    if (trophyAnimationFrame) {
        cancelAnimationFrame(trophyAnimationFrame);
        trophyAnimationFrame = 0;
    }
    setTrophyPopState(true, false);
    setTrophyPopState(false, false);
}

function setHudTrophiesValue(value) {
    const el = document.getElementById("trophyCount");
    if (el) el.innerText = String(value);
}

function setHudCoinsValue(value) {
    const el = document.getElementById("coinCount");
    if (el) el.innerText = String(value);
}

function setTrophyPopState(isMobile, active){
    const targetId = isMobile ? "gameOverTrophiesValue" : "trophyCount";
    const el = document.getElementById(targetId);
    if (!el) return;
    el.classList.toggle("trophy-pop", !!active);
}

function setGameOverTrophiesValue(value, delta) {
    const valueEl = document.getElementById("gameOverTrophiesValue");
    const deltaEl = document.getElementById("gameOverTrophiesDelta");
    if (valueEl) valueEl.innerText = String(value);
    if (!deltaEl) return;

    const signed = Number.isFinite(delta) ? Math.trunc(delta) : 0;
    if (signed > 0) {
        deltaEl.innerText = `(+${signed})`;
        deltaEl.classList.add("pos");
        deltaEl.classList.remove("neg");
        return;
    }
    if (signed < 0) {
        deltaEl.innerText = `(${signed})`;
        deltaEl.classList.add("neg");
        deltaEl.classList.remove("pos");
        return;
    }
    deltaEl.innerText = "(0)";
    deltaEl.classList.remove("pos", "neg");
}

function animateTrophiesAfterGame(beforeValue, deltaValue) {
    stopTrophyAnimation();

    const from = Math.max(0, Math.floor(beforeValue));
    const to = Math.max(0, Math.floor(beforeValue + deltaValue));
    const isMobile = window.matchMedia("(max-width: 900px)").matches;
    const deltaAbs = Math.abs(to - from);
    let duration;
    if (to > from && deltaAbs > 20) {
        // Большой прирост трофеев анимируем заметно медленнее.
        duration = 1200 + Math.min(3800, (deltaAbs - 20) * 55);
    } else {
        duration = 650 + Math.min(1100, deltaAbs * 30);
    }
    setGameOverTrophiesValue(from, deltaValue);
    if (!isMobile) {
        setHudTrophiesValue(from);
    }

    trophyAnimationStartTimeout = setTimeout(() => {
        trophyAnimationStartTimeout = 0;
        setTrophyPopState(isMobile, true);
        const animStart = performance.now();

        const step = (ts) => {
            const t = Math.min(1, (ts - animStart) / duration);
            const eased = 1 - Math.pow(1 - t, 3);
            const raw = from + (to - from) * eased;
            const shown = to >= from ? Math.floor(raw) : Math.ceil(raw);

            setGameOverTrophiesValue(shown, deltaValue);
            if (!isMobile) {
                setHudTrophiesValue(shown);
            }

            if (t < 1) {
                trophyAnimationFrame = requestAnimationFrame(step);
                return;
            }

            setGameOverTrophiesValue(to, deltaValue);
            setHudTrophiesValue(to);
            setTrophyPopState(isMobile, false);
            trophyAnimationFrame = 0;
        };

        trophyAnimationFrame = requestAnimationFrame(step);
    }, 2000);
}

function isRankedSession() {
    return !aiMode && !isReplaying && !sessionUsedAI && !sessionNoRewards;
}

function isRecordEligibleSession() {
    return !aiMode && !isReplaying && !sessionNoRewards;
}

function mutationRemainingMs(now = performance.now()) {
    if (!activeMutation) return 0;
    return Math.max(0, activeMutation.until - now);
}

function isMutationActive(id, now = performance.now()) {
    return !!activeMutation && activeMutation.id === id && mutationRemainingMs(now) > 0;
}

function clearMutation() {
    activeMutation = null;
    const el = document.getElementById("mutationDisplay");
    if (el) el.innerText = "-";
}

function updateMutationUI(now = performance.now()) {
    const el = document.getElementById("mutationDisplay");
    if (!el) return;
    if (!activeMutation) {
        el.innerText = "-";
        return;
    }
    const leftSec = Math.ceil(mutationRemainingMs(now) / 1000);
    if (leftSec <= 0) {
        clearMutation();
        return;
    }
    el.innerText = `${activeMutation.name} ${leftSec}s`;
}

function activateMutation(mutationId, durationMsOverride = null) {
    const base = MUTATIONS.find((m) => m.id === mutationId);
    if (!base) return;
    const durationMs = Number.isFinite(durationMsOverride) ? durationMsOverride : base.durationMs;
    activeMutation = {
        id: base.id,
        name: base.name,
        until: performance.now() + durationMs
    };
    updateMutationUI();
}

function maybeTriggerMutation() {
    if (!isRankedSession()) return;
    if (Math.random() > 0.22) return;

    const next = MUTATIONS[Math.floor(Math.random() * MUTATIONS.length)];
    activateMutation(next.id, next.durationMs);
}

function syncMenuOverlayState() {
    const menuIds = ["mainMenu", "gameOverMenu", "historyMenu", "accountMenu", "roomMenu", "skinMenu", "shopMenu"];
    const visible = menuIds.some((id) => {
        const el = document.getElementById(id);
        return !!el && !el.classList.contains("hidden");
    });
    document.body.classList.toggle("menu-active", visible);
}

function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
}

function updateResponsiveScale() {
    const vw = Math.max(280, window.innerWidth || document.documentElement.clientWidth || 0);
    const vh = Math.max(280, window.innerHeight || document.documentElement.clientHeight || 0);

    const widthScale = vw / 430;
    const heightScale = vh / 920;
    const next = clamp(Math.min(1, widthScale, heightScale), 0.56, 1);
    const extremeCompact = vw <= 390 || vh <= 690;

    document.documentElement.style.setProperty("--ui-scale", next.toFixed(3));
    document.body.classList.toggle("extreme-compact", extremeCompact);
}

function saveCosmetics() {
    localStorage.setItem("cosmetics", JSON.stringify(cosmetics));
}

function saveSnakeProgress() {
    localStorage.setItem("snakeProgress", JSON.stringify(snakeProgress));
}

function hashString(seed) {
    let h = 2166136261;
    for (let i = 0; i < seed.length; i++) {
        h ^= seed.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }
    return h >>> 0;
}

function mulberry32(a) {
    return function rand() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}

function todayKey() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
}

function createChallengeByTemplate(template, idx) {
    const baseId = `${template.type}-${template.target}-${idx}`;
    if (template.type === "eat") {
        return {
            id: baseId,
            type: "eat",
            target: template.target,
            reward: template.reward,
            progress: 0,
            done: false,
            title: `Съешь ${template.target} еды`
        };
    }
    if (template.type === "survive") {
        return {
            id: baseId,
            type: "survive",
            target: template.target,
            reward: template.reward,
            progress: 0,
            done: false,
            title: `Выживи ${Math.round(template.target / 60000)} минуты`
        };
    }
    return {
        id: baseId,
        type: "score",
        target: template.target,
        reward: template.reward,
        progress: 0,
        done: false,
        title: `Набери ${template.target} очков`
    };
}

function buildDailyChallenges() {
    const storageKey = "dailyChallenges";
    const key = todayKey();
    const raw = localStorage.getItem(storageKey);
    if (raw) {
        try {
            const parsed = JSON.parse(raw);
            if (parsed.dateKey === key && Array.isArray(parsed.tasks) && parsed.tasks.length) {
                return parsed;
            }
        } catch (e) {
            // generate new below
        }
    }

    const templates = [
        { type: "eat", target: 20, reward: 18 },
        { type: "survive", target: 180000, reward: 22 },
        { type: "eat", target: 12, reward: 12 },
        { type: "survive", target: 120000, reward: 16 },
        { type: "score", target: 18, reward: 14 },
        { type: "score", target: 24, reward: 20 }
    ];
    const random = mulberry32(hashString(key));
    const first = Math.floor(random() * templates.length);
    let second = Math.floor(random() * templates.length);
    if (second === first) {
        second = (second + 1) % templates.length;
    }

    const generated = {
        dateKey: key,
        tasks: [
            createChallengeByTemplate(templates[first], 1),
            createChallengeByTemplate(templates[second], 2)
        ]
    };

    localStorage.setItem(storageKey, JSON.stringify(generated));
    return generated;
}

function saveDailyChallenges() {
    localStorage.setItem("dailyChallenges", JSON.stringify(dailyChallenges));
}

function challengeProgressText(task) {
    if (task.type === "survive") {
        const seconds = Math.floor(task.progress / 1000);
        const targetSec = Math.floor(task.target / 1000);
        return `${task.title}: ${seconds}/${targetSec} сек (+${task.reward} монет)`;
    }
    return `${task.title}: ${task.progress}/${task.target} (+${task.reward} монет)`;
}

function refreshChallengeUI() {
    const taskA = dailyChallenges.tasks[0];
    const taskB = dailyChallenges.tasks[1];
    const a = document.getElementById("dailyChallengeA");
    const b = document.getElementById("dailyChallengeB");
    if (a && taskA) {
        a.innerText = `${challengeProgressText(taskA)}${taskA.done ? " [DONE]" : ""}`;
    }
    if (b && taskB) {
        b.innerText = `${challengeProgressText(taskB)}${taskB.done ? " [DONE]" : ""}`;
    }
}

function updateChallengeProgress(type, amountOrValue) {
    if (!dailyChallenges || !Array.isArray(dailyChallenges.tasks)) return;

    let changed = false;

    for (const task of dailyChallenges.tasks) {
        if (task.done || task.type !== type) continue;

        if (type === "survive") {
            task.progress = Math.max(task.progress, amountOrValue);
        } else if (type === "score") {
            task.progress = Math.max(task.progress, amountOrValue);
        } else {
            task.progress += amountOrValue;
        }

        if (task.progress >= task.target) {
            task.done = true;
            coins += task.reward;
            setHudCoinsValue(coins);
            localStorage.setItem("coins", coins);
            updateMenuTrophies();
        }

        changed = true;
    }

    if (changed) {
        saveDailyChallenges();
        refreshChallengeUI();
    }
}

function gainSnakeXp(amount) {
    if (!Number.isFinite(amount) || amount <= 0) return;
    snakeProgress.xp += amount;
    while (snakeProgress.xp >= snakeProgress.xpNeed) {
        snakeProgress.xp -= snakeProgress.xpNeed;
        snakeProgress.level += 1;
        snakeProgress.xpNeed = Math.round(snakeProgress.xpNeed * 1.25 + 3);
    }
    saveSnakeProgress();
    renderSnakeProgress();
}

function snakeLevelSpeedBonus() {
    return Math.min(140, (snakeProgress.level - 1) * 4);
}

function renderSnakeProgress() {
    const level = snakeProgress.level;
    const xp = Math.floor(snakeProgress.xp);
    const xpNeed = snakeProgress.xpNeed;
    document.getElementById("snakeLevelDisplay").innerText = `lvl ${level}`;
    document.getElementById("menuSnakeLevel").innerText = String(level);
    document.getElementById("menuSnakeXp").innerText = String(xp);
    document.getElementById("menuSnakeXpNeed").innerText = String(xpNeed);
}

function updateScoreDisplay() {
    const main = document.getElementById("liveScore");
    if (main) main.innerText = score;
    const top = document.getElementById("topScore");
    if (top) top.innerText = String(score);
}

function updateSpeedDisplay() {
    const el = document.getElementById("speedDisplay");
    if (el) el.innerText = String(Math.round(speed));
    const top = document.getElementById("topSpeed");
    if (top) top.innerText = String(Math.round(speed));
}

function isOwned(item) {
    return cosmetics.unlocked.includes(item.id);
}

function unlockItem(item) {
    if (!cosmetics.unlocked.includes(item.id)) {
        cosmetics.unlocked.push(item.id);
        saveCosmetics();
    }
}

function canEquip(item) {
    if (item.value === "classic") return true;
    return isOwned(item);
}

function equipItem(type, value) {
    if (type === "eatEffect") cosmetics.eatEffect = value;
    if (type === "foodType") cosmetics.foodType = value;
    saveCosmetics();
    applyCosmetics();
}

function applyNeonPack(pack) {
    if (!pack) return;
    cosmetics.foodColor = pack.foodColor;
    cosmetics.foodGlow = pack.foodGlow;
    cosmetics.particleColor = pack.particleColor;
    cosmetics.neonBoost = pack.neonBoost;
    saveCosmetics();
    applyCosmetics();
    syncSkinInputs();
}

function applyCosmetics() {
    setFoodRenderConfig({
        foodType: cosmetics.foodType,
        foodColor: cosmetics.foodColor,
        foodGlow: cosmetics.foodGlow,
        particleColor: cosmetics.particleColor,
        neonBoost: cosmetics.neonBoost
    });
    renderShop();
}

function syncSkinInputs() {
    const foodInput = document.getElementById("foodColorInput");
    const foodTypeSelect = document.getElementById("foodTypeSelect");
    const eatEffectSelect = document.getElementById("eatEffectSelect");
    if (foodInput) foodInput.value = cosmetics.foodColor;
    if (foodTypeSelect) foodTypeSelect.value = cosmetics.foodType;
    if (eatEffectSelect) eatEffectSelect.value = cosmetics.eatEffect;
}

function renderShop() {
    const list = document.getElementById("shopList");
    if (!list) return;

    list.innerHTML = "";
    for (const item of SHOP_ITEMS) {
        const row = document.createElement("div");
        row.className = "shopRow";
        const owned = isOwned(item);
        const equipped = cosmetics[item.type] === item.value;
        row.innerHTML = `
            <div>
                <div>${item.title}</div>
                <div class="shopOwned">${owned ? "Куплено" : `Цена: ${item.price} монет`}</div>
            </div>
        `;
        const button = document.createElement("button");
        if (!owned) {
            button.innerText = "Купить";
            button.disabled = coins < item.price;
            button.addEventListener("click", () => {
                if (coins < item.price) return;
                coins -= item.price;
                localStorage.setItem("coins", coins);
                setHudCoinsValue(coins);
                updateMenuTrophies();
                unlockItem(item);
                renderShop();
            });
        } else {
            button.innerText = equipped ? "Экипировано" : "Экипировать";
            button.disabled = equipped;
            button.addEventListener("click", () => {
                equipItem(item.type, item.value);
                renderShop();
            });
        }
        row.appendChild(button);
        list.appendChild(row);
    }
}

if (!cosmetics.unlocked.includes("food-plasma") && cosmetics.foodType === "plasma") cosmetics.foodType = "solar";
if (!cosmetics.unlocked.includes("food-void") && cosmetics.foodType === "void") cosmetics.foodType = "solar";
if (!cosmetics.unlocked.includes("food-toxic") && cosmetics.foodType === "toxic") cosmetics.foodType = "solar";
if (!cosmetics.unlocked.includes("eat-burst") && cosmetics.eatEffect === "burst") cosmetics.eatEffect = "spark";
if (!cosmetics.unlocked.includes("eat-ring") && cosmetics.eatEffect === "ring") cosmetics.eatEffect = "spark";
saveCosmetics();
applyCosmetics();
syncSkinInputs();
renderSnakeProgress();
refreshChallengeUI();
updateResponsiveScale();
document.body.classList.add("hide-level-progression");
syncMenuOverlayState();
renderAuthState();
bootstrapAccount();
window.addEventListener("resize", updateResponsiveScale, { passive: true });
window.addEventListener("orientationchange", updateResponsiveScale, { passive: true });
if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", updateResponsiveScale, { passive: true });
}
document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") {
        scheduleCloudSync(0);
        return;
    }
    if (accountToken && accountUser) {
        pullCloudIfRemoteIsNewer().catch((error) => console.error(error));
        if (roomState && roomState.roomCode) {
            pullRoomState(true).catch((error) => console.error(error));
        } else {
            restoreCurrentRoomState(false).catch((error) => console.error(error));
        }
    }
});

function normalizeAxisValue(value){
    if (!Number.isFinite(value)) return null;
    if (value > 0.5) return 1;
    if (value < -0.5) return -1;
    return 0;
}

function sanitizeReplayInputs(inputs){
    if(!Array.isArray(inputs)) return [];

    const sanitized = [];

    for (let i = 0; i < inputs.length; i++) {
        const ev = inputs[i];
        if(!ev || typeof ev !== "object") continue;

        const frame = Number.isFinite(ev.frame) ? Math.max(0, Math.floor(ev.frame)) : null;
        if (frame === null) continue;

        if (ev.eat === true) {
            sanitized.push({ frame, eat: true, _i: i });
            continue;
        }

        const x = normalizeAxisValue(ev.x);
        const y = normalizeAxisValue(ev.y);
        if (x === null || y === null) continue;
        if (Math.abs(x) + Math.abs(y) !== 1) continue;

        sanitized.push({ frame, x, y, _i: i });
    }

    sanitized.sort((a, b) => {
        if (a.frame !== b.frame) return a.frame - b.frame;
        return a._i - b._i;
    });

    let lastDirectionKey = null;
    const deduped = [];
    for (const ev of sanitized) {
        if (ev.eat) {
            deduped.push({ frame: ev.frame, eat: true });
            lastDirectionKey = null;
            continue;
        }

        const key = `${ev.frame}:${ev.x}:${ev.y}`;
        if (key === lastDirectionKey) continue;
        lastDirectionKey = key;
        deduped.push({ frame: ev.frame, x: ev.x, y: ev.y });
    }

    return deduped;
}

function sanitizeFoodHistory(foods){
    if(!Array.isArray(foods)) return [];

    const max = GRID * CELL;
    const result = [];
    for (const item of foods) {
        if (!item || typeof item !== "object") continue;
        if (!Number.isFinite(item.x) || !Number.isFinite(item.y)) continue;

        const x = Math.min(Math.max(item.x, CELL / 2), max - CELL / 2);
        const y = Math.min(Math.max(item.y, CELL / 2), max - CELL / 2);
        result.push({ x, y, eaten: false });
    }

    return result;
}

function pushDirectionEvent(x, y){
    if (isReplaying || !running) return;

    const frame = gameFrame;
    const nx = normalizeAxisValue(x);
    const ny = normalizeAxisValue(y);
    if (nx === null || ny === null) return;
    if (Math.abs(nx) + Math.abs(ny) !== 1) return;

    const last = currentReplay.length ? currentReplay[currentReplay.length - 1] : null;
    if (last && !last.eat && last.frame === frame && last.x === nx && last.y === ny) {
        return;
    }

    currentReplay.push({
        frame,
        x: nx,
        y: ny
    });
}

function pushEatEvent(){
    if (isReplaying || !running) return;

    const frame = gameFrame;
    const last = currentReplay.length ? currentReplay[currentReplay.length - 1] : null;
    if (last && last.eat === true && last.frame === frame) {
        return;
    }

    currentReplay.push({
        eat: true,
        frame
    });
}

function getFallbackFoodPoint(){
    return {
        x: Math.floor(GRID / 2) * CELL + CELL / 2,
        y: Math.floor(GRID / 2) * CELL + CELL / 2
    };
}

function normalizeHistoryRecord(raw, forceImported = false){
    if(!raw || typeof raw !== "object") return null;

    const fallbackFood = getFallbackFoodPoint();
    const safeInputs = sanitizeReplayInputs(raw.inputs);
    const sanitizedFoods = sanitizeFoodHistory(raw.foodHistory);
    const safeFoods = sanitizedFoods.length
        ? sanitizedFoods
        : [fallbackFood];
    const isImported = forceImported || !!raw.imported || !!raw.external;

    const normalized = {
        date: typeof raw.date === "string" ? raw.date : new Date().toLocaleDateString(),
        time: typeof raw.time === "string" ? raw.time : new Date().toLocaleTimeString(),
        score: Number.isFinite(raw.score) ? raw.score : 0,
        trophies: Number.isFinite(raw.trophies) ? raw.trophies : null,
        isAI: !!raw.isAI,
        noRewards: !!raw.noRewards,
        imported: isImported,
        seed: Number.isFinite(raw.seed) ? raw.seed : Math.floor(Date.now() % 1000000000),
        inputs: safeInputs,
        foodHistory: safeFoods,
        finalFrame: Number.isFinite(raw.finalFrame) ? raw.finalFrame : null,
        duration: Number.isFinite(raw.duration) ? raw.duration : 0,
        initialSpeed: Number.isFinite(raw.initialSpeed) ? raw.initialSpeed : null,
        initialTargetLength: Number.isFinite(raw.initialTargetLength) ? raw.initialTargetLength : 120,
        initialDir: (() => {
            if (!(raw.initialDir && Number.isFinite(raw.initialDir.x) && Number.isFinite(raw.initialDir.y))) {
                return { x: 1, y: 0 };
            }

            const x = normalizeAxisValue(raw.initialDir.x);
            const y = normalizeAxisValue(raw.initialDir.y);
            if (x === null || y === null) return { x: 1, y: 0 };
            if (Math.abs(x) + Math.abs(y) !== 1) return { x: 1, y: 0 };
            return { x, y };
        })()
    };

    if (normalized.imported) {
        normalized.trophies = null;
    }

    if (!Number.isFinite(normalized.finalFrame)) {
        const maxFrame = safeInputs.reduce((max, ev) => {
            const frame = Number.isFinite(ev?.frame) ? ev.frame : 0;
            return Math.max(max, frame);
        }, 0);
        normalized.finalFrame = maxFrame + Math.max(120, safeFoods.length * 25);
    }

    return normalized;
}

function persistHistory(){
    try {
        localStorage.setItem("gameHistory", JSON.stringify(gameHistory));
    } catch (e) {
        console.warn("История переполнена. Очищаем историю.");
        localStorage.removeItem("gameHistory");
        gameHistory = [];
        localStorage.setItem("gameHistory", JSON.stringify(gameHistory));
    }
}

function calculateTrophies(score){
    const current = Math.max(0, Math.floor(trophies));
    const league = Math.min(39, Math.floor(current / 50)); // 0..39 => до 2000
    const targetScore = 10 + Math.floor(league * 0.82);
    const scoreDiff = Math.floor(score) - targetScore;

    const maxWin = Math.max(2, 8 - Math.floor(league / 6));
    const medWin = Math.max(1, maxWin - 2);
    const minWin = Math.max(1, medWin - 1);
    const minLoss = -(1 + Math.floor(league / 7));
    const medLoss = -(2 + Math.floor(league / 5));
    const maxLoss = -(3 + Math.floor(league / 4));

    let delta = 0;
    if (scoreDiff >= 8) delta = maxWin;
    else if (scoreDiff >= 4) delta = medWin;
    else if (scoreDiff >= 1) delta = minWin;
    else if (scoreDiff <= -7) delta = maxLoss;
    else if (scoreDiff <= -3) delta = medLoss;
    else delta = minLoss;

    if (current >= 2000) {
        delta = Math.min(delta, 2);
        delta = Math.max(delta, -10);
    }

    let oldTrophies = trophies;

trophies += delta;

if(trophies < 0) trophies = 0;

localStorage.setItem("trophies", trophies);

updateRank();

return trophies - oldTrophies;
}



function updateSpeedByTrophies(){
    let speedByTrophies;
    if(trophies < 50){
        speedByTrophies = 320;
    }
    else if(trophies < 100){
        speedByTrophies = 350;
    }
    else if(trophies < 150){
        speedByTrophies = 400;
    }
    else{
        speedByTrophies = 450;
    }
    baseSpeed = speedByTrophies + snakeLevelSpeedBonus();
    speed = baseSpeed;
    updateSpeedDisplay();
}

function randomFood(){
    const margin = 1;
    const minCell = margin;
    const maxCell = GRID - 1 - margin;

    const insideMin = minCell <= maxCell;
    const low = insideMin ? minCell : 0;
    const high = insideMin ? maxCell : GRID - 1;

    function isCellFree(cellX, cellY) {
        if (!snake || !snake.length) return true;
        for (const segment of snake) {
            const sx = Math.floor(segment.x / CELL);
            const sy = Math.floor(segment.y / CELL);
            if (sx === cellX && sy === cellY) return false;
        }
        return true;
    }

    for (let i = 0; i < 220; i++) {
        const cellX = low + Math.floor(seededRandom() * (high - low + 1));
        const cellY = low + Math.floor(seededRandom() * (high - low + 1));
        if (!isCellFree(cellX, cellY)) continue;
        return {
            x: cellX * CELL + CELL/2,
            y: cellY * CELL + CELL/2,
            eaten: false
        };
    }

    for (let y = low; y <= high; y++) {
        for (let x = low; x <= high; x++) {
            if (!isCellFree(x, y)) continue;
            return {
                x: x * CELL + CELL / 2,
                y: y * CELL + CELL / 2,
                eaten: false
            };
        }
    }

    return {
        x: Math.floor(GRID / 2) * CELL + CELL/2,
        y: Math.floor(GRID / 2) * CELL + CELL/2,
        eaten: false
    };
}
function update(delta){
    const now = performance.now();
    updateMutationUI(now);

    if(isRankedSession() && running){
        survivalMsCurrentRun += delta;
        updateChallengeProgress("survive", survivalMsCurrentRun);
    }

if(aiMode){
    sessionUsedAI = true;
    aiTimer += delta;

    if(aiTimer >= aiInterval){
        aiTimer = 0;

        const newDir = runAI(snake, food, dir);
        if(newDir){
            const changed = newDir.x !== dir.x || newDir.y !== dir.y;
            dir = newDir;

            if(changed && !isReplaying){
                pushDirectionEvent(dir.x, dir.y);
            }
        }
    }
}
    if(!aiMode && !isReplaying && pendingPlayerDir){
        const nx = pendingPlayerDir.x;
        const ny = pendingPlayerDir.y;
        const changed = nx !== dir.x || ny !== dir.y;
        dir = { x: nx, y: ny };
        pendingPlayerDir = null;
        if(changed){
            pushDirectionEvent(dir.x, dir.y);
        }
    }

    const speedMultiplier = isMutationActive("overdrive", now) ? 1.28 : 1;
    let move = speed * speedMultiplier * (FIXED_STEP/1000);

    const head = {
        x: snake[0].x + dir.x * move,
        y: snake[0].y + dir.y * move
    };

    snake.unshift(head);

    // корректируем длину
    let length = 0;
    for(let i=1;i<snake.length;i++){
        const dx = snake[i].x - snake[i-1].x;
        const dy = snake[i].y - snake[i-1].y;
        length += Math.sqrt(dx*dx + dy*dy);
    }

    while(length > targetLength){
        snake.pop();

        length = 0;
        for(let i=1;i<snake.length;i++){
            const dx = snake[i].x - snake[i-1].x;
            const dy = snake[i].y - snake[i-1].y;
            length += Math.sqrt(dx*dx + dy*dy);
        }
    }
    if(checkCollision()) return;

if(!isReplaying){
    checkFood();
}
    stateFrames.push({
        snake: snake.map(segment => ({
            x: Math.round(segment.x * 100) / 100,
            y: Math.round(segment.y * 100) / 100
        })),
        food: {
            x: Math.round(food.x * 100) / 100,
            y: Math.round(food.y * 100) / 100
        },
        score: score,
        level: level,
        speed: speed,
        targetLength: targetLength
    });
    gameFrame++;
    }


function checkCollision(){
    const head = snake[0];
    const phaseActive = isMutationActive("phase");

    const collidedWithWall = head.x < 0 || head.y < 0 || head.x >= size || head.y >= size;
    if(collidedWithWall){
        if(isReplaying){
            running = false;
        } else {
            gameOver();
        }
        return true;
    }

    for(let i = 15; i < snake.length; i++){
        const dx = head.x - snake[i].x;
        const dy = head.y - snake[i].y;

        if((dx*dx + dy*dy) < 225){
            if (phaseActive) {
                continue;
            }
            if(isReplaying){
                running = false;
            } else {
                gameOver();
            }
            return true;
        }
    }

    return false;
}


function checkFood(){
    const head = snake[0];
    const dx = head.x - food.x;
    const dy = head.y - food.y;
    const captureRadius = isMutationActive("magnet") ? 30 : 20;

    if(Math.sqrt(dx*dx + dy*dy) < captureRadius && !food.eaten){
        spawnEatEffect(food.x, food.y);

        score++;
        food.eaten = true;
        if(!isReplaying){
    pushEatEvent();
}
        updateScoreDisplay();
        if (inRoomChallengeSession()) {
            sendRoomScore(score, false);
        }
        let newLevel = Math.floor(score / 5) + 1;

if(newLevel !== level){
    level = newLevel;
    document.getElementById("levelDisplay").innerText = level;
        if (inRoomChallengeSession()) {
            speed = getRoomConfiguredSpeed();
        } else {
            speed += aiMode ? 22 : 30;
            if (aiMode) {
                speed = Math.min(speed, 620);
            }
        }
        updateSpeedDisplay();

}
        if(isRankedSession()){
            updateChallengeProgress("eat", 1);
            updateChallengeProgress("score", score);
            gainSnakeXp(2);
            maybeTriggerMutation();
        }
        targetLength += 40;
        if(isReplaying){
    return;
}

food = randomFood();

foodHistory.push({
    x: food.x,
    y: food.y,
    eaten: false
});
}}
function buildHamiltonianPath(){

    let path = [];

    for(let y = 0; y < GRID; y++){

        if(y % 2 === 0){
            for(let x = 0; x < GRID; x++){
                path.push({x, y});
            }
        } else {
            for(let x = GRID - 1; x >= 0; x--){
                path.push({x, y});
            }
        }

    }

    return path;
}

function hexToRgba(hex, alpha){
    if(typeof hex !== "string") return `rgba(255,122,0,${alpha})`;
    const clean = hex.replace("#", "").trim();
    const value = clean.length === 3
        ? clean.split("").map((c) => c + c).join("")
        : clean.padEnd(6, "0").slice(0, 6);
    const num = Number.parseInt(value, 16);
    if(!Number.isFinite(num)) return `rgba(255,122,0,${alpha})`;
    const r = (num >> 16) & 255;
    const g = (num >> 8) & 255;
    const b = num & 255;
    return `rgba(${r},${g},${b},${alpha})`;
}

function spawnEatEffect(x, y){
    eatFx.push({
        x,
        y,
        started: performance.now(),
        mode: cosmetics.eatEffect || "spark"
    });
}

function drawEatEffects(){
    if(!eatFx.length) return;
    const now = performance.now();
    eatFx = eatFx.filter((fx) => now - fx.started < 480);
    for (const fx of eatFx) {
        const age = (now - fx.started) / 480;
        const t = Math.max(0, 1 - age);
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.strokeStyle = hexToRgba(cosmetics.foodGlow, 0.85 * t);
        ctx.fillStyle = hexToRgba(cosmetics.particleColor, 0.65 * t);
        ctx.shadowColor = cosmetics.foodGlow;
        ctx.shadowBlur = 18 * t * (cosmetics.neonBoost || 1);

        if (fx.mode === "burst") {
            for (let i = 0; i < 10; i++) {
                const a = i * ((Math.PI * 2) / 10);
                const dist = 8 + age * 40;
                const px = fx.x + Math.cos(a) * dist;
                const py = fx.y + Math.sin(a) * dist;
                ctx.beginPath();
                ctx.arc(px, py, 2.2 * t, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (fx.mode === "ring") {
            ctx.lineWidth = 4 * t;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, 14 + age * 42, 0, Math.PI * 2);
            ctx.stroke();
        } else {
            for (let i = 0; i < 7; i++) {
                const a = age * 8 + i * ((Math.PI * 2) / 7);
                const dist = 8 + Math.sin(age * 10 + i) * 8 + age * 22;
                const px = fx.x + Math.cos(a) * dist;
                const py = fx.y + Math.sin(a) * dist;
                ctx.beginPath();
                ctx.arc(px, py, 1.8 + t * 1.6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.restore();
    }
}

function draw(){
renderBackground();
const phaseActive = isMutationActive("phase");
const overdriveActive = isMutationActive("overdrive");

ctx.beginPath();
ctx.lineCap="round";
ctx.lineJoin="round";
ctx.lineWidth=20;
ctx.shadowColor=phaseActive ? "#35d9ff" : (overdriveActive ? "#ffd24a" : "#ff7a00");
ctx.strokeStyle=phaseActive ? "#63f1ff" : (overdriveActive ? "#ffd45f" : "#ff7a00");
ctx.shadowBlur=overdriveActive ? 34 : 26;
ctx.moveTo(snake[0].x,snake[0].y);
for(let i=1;i<snake.length;i++){
ctx.lineTo(snake[i].x,snake[i].y);
}
ctx.stroke();

renderFood(food);
drawEatEffects();
}

function loop(timestamp){
if(!running) {
    draw();
    return;
}
const delta=timestamp-lastTime;
lastTime=timestamp;
accumulator += delta;

while(accumulator >= FIXED_STEP){
    update(FIXED_STEP);
    accumulator -= FIXED_STEP;
}

draw();
requestAnimationFrame(loop);
}

function startGame(ai=false, noRewards=false){
stopTrophyAnimation();
document.body.classList.remove("gameover-active");
dailyChallenges = buildDailyChallenges();
refreshChallengeUI();
isReplaying = false
gameFrame = 0;
stateFrames = [];
replaySeed = Math.floor(Date.now() % 1000000000);
foodHistory = [];
gameStartTime = performance.now();
aiMode=ai;
sessionUsedAI = !!ai;
sessionNoRewards = !!noRewards;
sessionStartTrophies = trophies;
pendingPlayerDir = null;
clearMutation();
document.getElementById("mainMenu").classList.add("hidden");
document.getElementById("gameOverMenu").classList.add("hidden");
document.getElementById("roomMenu").classList.add("hidden");
document.getElementById("exitBtn").classList.remove("hidden");
document.getElementById("roomResultText").innerText = "";
init();
if (aiMode) {
    speed = Math.max(280, speed - 30);
}
if (inRoomChallengeSession()) {
    const roomSpeed = getRoomConfiguredSpeed();
    baseSpeed = roomSpeed;
    speed = roomSpeed;
}
updateSpeedDisplay();
resetAI(snake);
sessionStartSpeed = speed;
sessionStartTargetLength = targetLength;
sessionStartDir = {x: dir.x, y: dir.y};
stateFrames.push({
    snake: JSON.parse(JSON.stringify(snake)),
    food: { x: food.x, y: food.y },
    score: score,
    level: level,
    speed: speed,
    targetLength: targetLength
});
foodHistory.push({
    x: food.x,
    y: food.y,
    eaten: false
});
running=true;
currentReplay = [];
lastTime=performance.now();
if (inRoomChallengeSession()) {
    resetRoomSessionFlags();
    roomLastPostedScore = 0;
}
syncMenuOverlayState();
requestAnimationFrame(loop);
}

function gameOver(){
    if(!running) return;   // 🔥 защита от повторного вызова
    running = false;
    const wasAI = aiMode || sessionUsedAI;
    let trophyChange = null;
    isReplaying = false

    if(isRankedSession()){
        trophyChange = calculateTrophies(score);
        gainSnakeXp(Math.max(1, Math.floor(score / 2)));
    }

    saveGameToHistory(score, trophyChange, wasAI);

    updateSpeedByTrophies();
    updateMenuTrophies();

    document.getElementById("finalScore").innerText = score;
    if (inRoomChallengeSession()) {
        sendRoomScore(score, true);
    }
    updateGameOverRoomControls();
    document.getElementById("gameOverMenu").classList.remove("hidden");
    document.getElementById("exitBtn").classList.add("hidden");
    document.body.classList.add("gameover-active");
    syncMenuOverlayState();
    const totalRunDelta = trophies - sessionStartTrophies;
    animateTrophiesAfterGame(sessionStartTrophies, totalRunDelta);
    scheduleCloudSync(500);

    if(isRecordEligibleSession() && score > best){
        best = score;
        localStorage.setItem("best", best);
        updateBestDisplay();
    }

    deathCount++;
}

document.getElementById("playBtn").addEventListener("click", () => {
    startGame(false, false);
});

document.getElementById("trainBtn").addEventListener("click", () => {
    startGame(false, true);
});

document.getElementById("aiBtn").addEventListener("click", () => {
    startGame(true, false);
});

document.getElementById("roomBtn").addEventListener("click", () => {
    closeMainMenuGroups();
    document.getElementById("mainMenu").classList.add("hidden");
    document.getElementById("roomMenu").classList.remove("hidden");
    restoreCurrentRoomState(true).then((room) => {
        refreshPublicRoomsList();
        if (room) {
            startRoomPolling();
            pullRoomState(true);
        } else {
            refreshRoomUI();
        }
    });
    syncMenuOverlayState();
});

document.getElementById("roomCreateBtn").addEventListener("click", async () => {
    if (!accountUser || !accountToken) {
        setRoomStatus("Сначала войдите в аккаунт.");
        return;
    }
    try {
        const target = Number.parseInt(document.getElementById("roomTargetInput").value || "20", 10);
        const snakeSpeed = Number.parseInt(document.getElementById("roomSpeedInput").value || "320", 10);
        const maxPlayers = Number.parseInt(document.getElementById("roomMaxPlayersInput").value || "2", 10);
        const isPublic = !!document.getElementById("roomPublicInput").checked;
        const data = await apiRequest("room-create", {
            method: "POST",
            body: { targetScore: target, snakeSpeed, maxPlayers, isPublic }
        });
        applyRoomState(data.room || null);
        roomLastStartedChallengeId = roomState ? Number(roomState.challengeId || 0) : 0;
        startRoomPolling();
        setRoomStatus("Комната создана. Поделитесь кодом с другом.");
    } catch (error) {
        const msg = error && error.code ? error.code : "ошибка создания комнаты";
        setRoomStatus(`Ошибка: ${msg}`);
        console.error(error);
    }
});

document.getElementById("roomJoinBtn").addEventListener("click", async () => {
    if (!accountUser || !accountToken) {
        setRoomStatus("Сначала войдите в аккаунт.");
        return;
    }
    try {
        const roomCode = document.getElementById("roomCodeInput").value.trim().toUpperCase();
        const data = await apiRequest("room-join", {
            method: "POST",
            body: { roomCode }
        });
        applyRoomState(data.room || null);
        roomLastStartedChallengeId = roomState ? Number(roomState.challengeId || 0) : 0;
        startRoomPolling();
        setRoomStatus("Вы вошли в комнату.");
    } catch (error) {
        const msg = error && error.code ? error.code : "ошибка входа";
        if (msg === "already_in_room") {
            await restoreCurrentRoomState(true);
            return;
        }
        setRoomStatus(`Ошибка: ${msg}`);
        console.error(error);
    }
});

document.getElementById("roomRefreshBtn").addEventListener("click", async () => {
    await refreshPublicRoomsList();
    const restored = await restoreCurrentRoomState(false);
    if (!restored) {
        refreshRoomUI();
        return;
    }
    await pullRoomState(true);
});

document.getElementById("roomPublicRefreshBtn").addEventListener("click", async () => {
    await refreshPublicRoomsList();
});

document.getElementById("roomSetTargetBtn").addEventListener("click", async () => {
    if (!roomState) return;
    try {
        const target = Number.parseInt(document.getElementById("roomTargetInput").value || "20", 10);
        const snakeSpeed = Number.parseInt(document.getElementById("roomSpeedInput").value || "320", 10);
        const maxPlayers = Number.parseInt(document.getElementById("roomMaxPlayersInput").value || "2", 10);
        const isPublic = !!document.getElementById("roomPublicInput").checked;
        const data = await apiRequest("room-set-target", {
            method: "POST",
            body: { roomCode: roomState.roomCode, targetScore: target, snakeSpeed, maxPlayers, isPublic }
        });
        applyRoomState(data.room || null);
    } catch (error) {
        const msg = error && error.code ? error.code : "ошибка цели";
        if (msg === "max_players_too_low") {
            setRoomStatus("Нельзя поставить лимит игроков меньше текущего количества в комнате.");
            return;
        }
        setRoomStatus(`Ошибка: ${msg}`);
        console.error(error);
    }
});

document.getElementById("roomStartBtn").addEventListener("click", async () => {
    if (!roomState) return;
    try {
        const data = await apiRequest("room-start", {
            method: "POST",
            body: { roomCode: roomState.roomCode }
        });
        applyRoomState(data.room || null);
        startRoomPolling();
        await pullRoomState(true);
    } catch (error) {
        const msg = error && error.code ? error.code : "ошибка старта";
        if (msg === "room_not_full") {
            setRoomStatus("Комната не заполнена до установленного лимита игроков.");
            return;
        }
        setRoomStatus(`Ошибка: ${msg}`);
        console.error(error);
    }
});

document.getElementById("roomRematchMenuBtn").addEventListener("click", async () => {
    if (!roomState) return;
    try {
        const data = await apiRequest("room-rematch", {
            method: "POST",
            body: { roomCode: roomState.roomCode }
        });
        applyRoomState(data.room || null);
        setRoomStatus("Челлендж сброшен. Лидер может запустить новый старт.");
    } catch (error) {
        const msg = error && error.code ? error.code : "ошибка реванша";
        setRoomStatus(`Ошибка: ${msg}`);
        console.error(error);
    }
});

document.getElementById("roomLeaveMenuBtn").addEventListener("click", async () => {
    if (!roomState) return;
    try {
        await apiRequest("room-leave", {
            method: "POST",
            body: { roomCode: roomState.roomCode }
        });
        applyRoomState(null);
        setRoomStatus("Вы вышли из комнаты.");
    } catch (error) {
        const msg = error && error.code ? error.code : "ошибка выхода";
        setRoomStatus(`Ошибка: ${msg}`);
        console.error(error);
    }
});

document.getElementById("closeRoomMenuBtn").addEventListener("click", () => {
    document.getElementById("roomMenu").classList.add("hidden");
    document.getElementById("mainMenu").classList.remove("hidden");
    closeMainMenuGroups();
    syncMenuOverlayState();
});

document.getElementById("authLoginBtn").addEventListener("click", async () => {
    await loginOrRegister("auth-login");
    refreshRoomUI();
});

document.getElementById("authRegisterBtn").addEventListener("click", async () => {
    await loginOrRegister("auth-register");
    refreshRoomUI();
});

document.getElementById("authUpdateNicknameBtn").addEventListener("click", async () => {
    await updateNickname();
});

document.getElementById("authLogoutBtn").addEventListener("click", () => {
    logoutAccount(true);
});

document.getElementById("roomCodeInput").addEventListener("input", (event) => {
    const next = String(event.target.value || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 8);
    event.target.value = next;
});

document.getElementById("authSyncBtn").addEventListener("click", async () => {
    renderAuthState("синхронизация...");
    await syncCloudProgressNow();
});

document.getElementById("accountBtn").addEventListener("click", () => {
    closeMainMenuGroups();
    document.getElementById("mainMenu").classList.add("hidden");
    document.getElementById("accountMenu").classList.remove("hidden");
    syncMenuOverlayState();
});

document.getElementById("closeAccountMenuBtn").addEventListener("click", () => {
    document.getElementById("accountMenu").classList.add("hidden");
    document.getElementById("mainMenu").classList.remove("hidden");
    closeMainMenuGroups();
    syncMenuOverlayState();
});

function setMainMenuGroup(mode){
    const mainMenu = document.getElementById("mainMenu");
    const playModes = document.getElementById("playModes");
    const settingsPanel = document.getElementById("settingsPanel");
    const backBtn = document.getElementById("mainMenuBackBtn");

    const isPlay = mode === "play";
    const isSettings = mode === "settings";

    mainMenu.classList.toggle("submenu-open", isPlay || isSettings);
    mainMenu.classList.toggle("submenu-play", isPlay);
    mainMenu.classList.toggle("submenu-settings", isSettings);

    playModes.classList.toggle("hidden", !isPlay);
    settingsPanel.classList.toggle("hidden", !isSettings);
    backBtn.classList.toggle("hidden", !(isPlay || isSettings));
}

function closeMainMenuGroups(){
    setMainMenuGroup("none");
}

document.getElementById("playGroupBtn").addEventListener("click", () => {
    const mainMenu = document.getElementById("mainMenu");
    if(mainMenu.classList.contains("submenu-play")){
        closeMainMenuGroups();
        return;
    }
    setMainMenuGroup("play");
});

document.getElementById("settingsGroupBtn").addEventListener("click", () => {
    const mainMenu = document.getElementById("mainMenu");
    if(mainMenu.classList.contains("submenu-settings")){
        closeMainMenuGroups();
        return;
    }
    setMainMenuGroup("settings");
});

document.getElementById("mainMenuBackBtn").addEventListener("click", () => {
    closeMainMenuGroups();
});

document.getElementById("skinEditorBtn").addEventListener("click", () => {
    closeMainMenuGroups();
    document.getElementById("mainMenu").classList.add("hidden");
    document.getElementById("skinMenu").classList.remove("hidden");
    syncSkinInputs();
    syncMenuOverlayState();
});

document.getElementById("shopBtn").addEventListener("click", () => {
    closeMainMenuGroups();
    document.getElementById("mainMenu").classList.add("hidden");
    document.getElementById("shopMenu").classList.remove("hidden");
    updateMenuTrophies();
    renderShop();
    syncMenuOverlayState();
});

document.getElementById("closeSkinMenuBtn").addEventListener("click", () => {
    document.getElementById("skinMenu").classList.add("hidden");
    document.getElementById("mainMenu").classList.remove("hidden");
    closeMainMenuGroups();
    syncMenuOverlayState();
});

document.getElementById("closeShopBtn").addEventListener("click", () => {
    document.getElementById("shopMenu").classList.add("hidden");
    document.getElementById("mainMenu").classList.remove("hidden");
    closeMainMenuGroups();
    syncMenuOverlayState();
});

document.getElementById("foodColorInput").addEventListener("input", (event) => {
    cosmetics.foodColor = event.target.value;
    saveCosmetics();
    applyCosmetics();
});

document.getElementById("foodTypeSelect").addEventListener("change", (event) => {
    const value = event.target.value;
    if (value === "solar") {
        cosmetics.foodType = value;
    } else {
        const requiredId = `food-${value}`;
        if (!cosmetics.unlocked.includes(requiredId)) {
            event.target.value = cosmetics.foodType;
            alert("Этот тип еды нужно купить за трофеи.");
            return;
        }
        cosmetics.foodType = value;
    }
    saveCosmetics();
    applyCosmetics();
});

document.getElementById("eatEffectSelect").addEventListener("change", (event) => {
    const value = event.target.value;
    if (value === "spark") {
        cosmetics.eatEffect = value;
    } else {
        const requiredId = `eat-${value}`;
        if (!cosmetics.unlocked.includes(requiredId)) {
            event.target.value = cosmetics.eatEffect;
            alert("Этот эффект поедания нужно купить.");
            return;
        }
        cosmetics.eatEffect = value;
    }
    saveCosmetics();
    applyCosmetics();
});

document.querySelectorAll("[data-neon-pack]").forEach((btn) => {
    btn.addEventListener("click", () => {
        const key = btn.getAttribute("data-neon-pack");
        applyNeonPack(NEON_PACKS[key]);
    });
});

document.getElementById("restartBtn").addEventListener("click", () => {
    if (inRoomChallengeSession()) {
        if (roomState && roomState.status === "active") {
            startGame(false, true);
        }
        return;
    }
    startGame(aiMode, sessionNoRewards);
});

document.getElementById("roomRematchBtn").addEventListener("click", async () => {
    if (!roomState) return;
    try {
        const resetData = await apiRequest("room-rematch", {
            method: "POST",
            body: { roomCode: roomState.roomCode }
        });
        applyRoomState(resetData.room || null);

        const startData = await apiRequest("room-start", {
            method: "POST",
            body: { roomCode: roomState.roomCode }
        });
        applyRoomState(startData.room || null);
        roomLastStartedChallengeId = 0;
        await pullRoomState(true);
    } catch (error) {
        const msg = error && error.code ? error.code : "ошибка реванша";
        const roomResultEl = document.getElementById("roomResultText");
        if (roomResultEl) roomResultEl.innerText = `Ошибка: ${msg}`;
        console.error(error);
    }
});

document.getElementById("roomLeaveBtn").addEventListener("click", async () => {
    if (!roomState) return;
    try {
        await apiRequest("room-leave", {
            method: "POST",
            body: { roomCode: roomState.roomCode }
        });
    } catch (error) {
        console.error(error);
    }
    applyRoomState(null);
    roomSession = { active: false, roomCode: "", challengeId: 0 };
    document.getElementById("gameOverMenu").classList.add("hidden");
    document.getElementById("mainMenu").classList.remove("hidden");
    closeMainMenuGroups();
    syncMenuOverlayState();
});

document.getElementById("exitBtn").addEventListener("click", () => {
    stopTrophyAnimation();
    document.body.classList.remove("gameover-active");

    running = false;
    isReplaying = false;

    document.getElementById("exitBtn").classList.add("hidden");
    document.getElementById("gameOverMenu").classList.add("hidden");
    document.getElementById("historyMenu").classList.add("hidden");
    document.getElementById("accountMenu").classList.add("hidden");
    document.getElementById("roomMenu").classList.add("hidden");
    document.getElementById("skinMenu").classList.add("hidden");
    document.getElementById("shopMenu").classList.add("hidden");

    if (inRoomChallengeSession() && roomState) {
        document.getElementById("roomMenu").classList.remove("hidden");
        startRoomPolling();
        pullRoomState(true);
    } else {
        document.getElementById("mainMenu").classList.remove("hidden");
    }
    closeMainMenuGroups();
    syncMenuOverlayState();
});


document.getElementById("menuBtn").addEventListener("click", () => {
    stopTrophyAnimation();
    document.body.classList.remove("gameover-active");
    running = false;

    document.getElementById("gameOverMenu").classList.add("hidden");
    document.getElementById("accountMenu").classList.add("hidden");
    document.getElementById("roomMenu").classList.add("hidden");
    document.getElementById("skinMenu").classList.add("hidden");
    document.getElementById("shopMenu").classList.add("hidden");
    updateMenuTrophies();
    if (inRoomChallengeSession() && roomState) {
        document.getElementById("roomMenu").classList.remove("hidden");
        startRoomPolling();
        pullRoomState(true);
    } else {
        document.getElementById("mainMenu").classList.remove("hidden");
    }
    closeMainMenuGroups();
    syncMenuOverlayState();
});

function queuePlayerDirection(x, y){
    if(aiMode || isReplaying || !running) return;
    const nx = normalizeAxisValue(x);
    const ny = normalizeAxisValue(y);
    if(nx === null || ny === null) return;
    if(Math.abs(nx) + Math.abs(ny) !== 1) return;
    if(nx === -dir.x && ny === -dir.y) return;
    pendingPlayerDir = { x: nx, y: ny };
}

document.addEventListener("keydown", e => {
    if(aiMode || isReplaying) return;

    const k = e.key.toLowerCase();

    if(k==="arrowup"||k==="w"||k==="ц"){
        document.getElementById("keyUp").classList.add("active");
        queuePlayerDirection(0, -1);
    }
    if(k==="arrowdown"||k==="s"||k==="ы"){
        document.getElementById("keyDown").classList.add("active");
        queuePlayerDirection(0, 1);
    }
    if(k==="arrowleft"||k==="a"||k==="ф"){
        document.getElementById("keyLeft").classList.add("active");
        queuePlayerDirection(-1, 0);
    }
    if(k==="arrowright"||k==="d"||k==="в"){
        document.getElementById("keyRight").classList.add("active");
        queuePlayerDirection(1, 0);
    }
});

document.addEventListener("keyup", e => {
    const k = e.key.toLowerCase();

    if(k==="arrowup"||k==="w"||k==="ц")
        document.getElementById("keyUp").classList.remove("active");

    if(k==="arrowdown"||k==="s"||k==="ы")
        document.getElementById("keyDown").classList.remove("active");

    if(k==="arrowleft"||k==="a"||k==="ф")
        document.getElementById("keyLeft").classList.remove("active");

    if(k==="arrowright"||k==="d"||k==="в")
        document.getElementById("keyRight").classList.remove("active");
});

function setDirection(x, y){
    queuePlayerDirection(x, y);
}

function pulseHaptic(){
    if (navigator.vibrate) {
        navigator.vibrate(10);
    }
}

function bindTouchDirection(id, x, y){
    const key = document.getElementById(id);
    if(!key) return;

    key.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        setDirection(x, y);
        pulseHaptic();
    }, { passive: false });
}

bindTouchDirection("keyUp", 0, -1);
bindTouchDirection("keyDown", 0, 1);
bindTouchDirection("keyLeft", -1, 0);
bindTouchDirection("keyRight", 1, 0);
document.querySelectorAll(".key").forEach(key=>{
    key.addEventListener("pointerdown", ()=>{
        key.classList.add("active");
    });

    key.addEventListener("pointerup", ()=>{
        key.classList.remove("active");
    });

    key.addEventListener("pointerleave", ()=>{
        key.classList.remove("active");
    });
});
updateRank();

// 🔥 Сброс прогресса через консоль
window.resetProgress = function(){

    localStorage.removeItem("trophies");
    localStorage.removeItem("coins");
    localStorage.removeItem("rankRewardClaimedRank");
    localStorage.removeItem("best");
    localStorage.removeItem("snakeProgress");
    localStorage.removeItem("cosmetics");
    localStorage.removeItem("dailyChallenges");

    trophies = 0;
    coins = 0;
    rankRewardClaimedRank = 0;
    best = 0;
    snakeProgress = { ...defaultSnakeProgress };
    cosmetics = { ...defaultCosmetics };
    dailyChallenges = buildDailyChallenges();

    setHudTrophiesValue(trophies);
    setHudCoinsValue(coins);
    updateBestDisplay();
    updateMenuTrophies();
    updateRank();
    renderSnakeProgress();
    applyCosmetics();
    syncSkinInputs();
    refreshChallengeUI();

    console.log("Прогресс обнулён");
    scheduleCloudSync(0);
};
document.getElementById("historyBtn").addEventListener("click", () => {

    closeMainMenuGroups();
    document.getElementById("mainMenu").classList.add("hidden");
    document.getElementById("historyMenu").classList.remove("hidden");

    renderHistory();
    syncMenuOverlayState();
});

document.getElementById("closeHistoryBtn").addEventListener("click", () => {

    document.getElementById("historyMenu").classList.add("hidden");
    document.getElementById("mainMenu").classList.remove("hidden");
    closeMainMenuGroups();
    syncMenuOverlayState();
});

document.getElementById("exportHistoryBtn").addEventListener("click", () => {
    if(!gameHistory.length){
        alert("История пуста, экспортировать нечего.");
        return;
    }

    exportGamesPayload(gameHistory, "history");
});

function exportGamesPayload(games, suffix = "history"){
    const payload = {
        type: "snake-neon-history",
        version: 1,
        exportedAt: new Date().toISOString(),
        games: Array.isArray(games) ? games : []
    };

    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `snake-${suffix}-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
}

function exportFullProgressPayload(){
    const payload = {
        type: "snake-neon-progress",
        version: 1,
        exportedAt: new Date().toISOString(),
        progress: {
            trophies,
            coins,
            rankRewardClaimedRank,
            best,
            snakeProgress,
            cosmetics,
            dailyChallenges,
            gameHistory
        }
    };

    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `snake-progress-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
}

function applyImportedProgress(progressRaw){
    if(!progressRaw || typeof progressRaw !== "object"){
        throw new Error("invalid progress payload");
    }

    const nextTrophies = Number.isFinite(progressRaw.trophies)
        ? Math.max(0, Math.floor(progressRaw.trophies))
        : 0;
    const nextCoins = Number.isFinite(progressRaw.coins)
        ? Math.max(0, Math.floor(progressRaw.coins))
        : 0;
    const fallbackClaimedByTrophies = Math.min(50, Math.floor(getRankNumberFromTrophies(nextTrophies) / 5) * 5);
    const nextRankRewardClaimedRank = Number.isFinite(progressRaw.rankRewardClaimedRank)
        ? Math.max(0, Math.min(50, Math.floor(progressRaw.rankRewardClaimedRank)))
        : fallbackClaimedByTrophies;
    const nextBest = Number.isFinite(progressRaw.best)
        ? Math.max(0, Math.floor(progressRaw.best))
        : 0;

    const nextSnakeProgress = {
        level: Number.isFinite(progressRaw.snakeProgress?.level) ? Math.max(1, Math.floor(progressRaw.snakeProgress.level)) : 1,
        xp: Number.isFinite(progressRaw.snakeProgress?.xp) ? Math.max(0, progressRaw.snakeProgress.xp) : 0,
        xpNeed: Number.isFinite(progressRaw.snakeProgress?.xpNeed) ? Math.max(5, Math.floor(progressRaw.snakeProgress.xpNeed)) : 10
    };

    const parsedCosmetics = (progressRaw.cosmetics && typeof progressRaw.cosmetics === "object") ? progressRaw.cosmetics : {};
    const unlocked = Array.isArray(parsedCosmetics.unlocked) ? parsedCosmetics.unlocked : [];
    const nextCosmetics = {
        ...defaultCosmetics,
        ...parsedCosmetics,
        unlocked: Array.from(new Set(["classic", ...unlocked]))
    };

    const nextHistory = Array.isArray(progressRaw.gameHistory)
        ? progressRaw.gameHistory.map((item) => normalizeHistoryRecord(item, !!item?.imported)).filter(Boolean).slice(0, 50)
        : [];

    let nextDaily = null;
    if (progressRaw.dailyChallenges && typeof progressRaw.dailyChallenges === "object" && Array.isArray(progressRaw.dailyChallenges.tasks)) {
        nextDaily = progressRaw.dailyChallenges;
    } else {
        nextDaily = buildDailyChallenges();
    }

    trophies = nextTrophies;
    coins = nextCoins;
    rankRewardClaimedRank = nextRankRewardClaimedRank;
    best = nextBest;
    snakeProgress = nextSnakeProgress;
    cosmetics = nextCosmetics;
    gameHistory = nextHistory;
    dailyChallenges = nextDaily;

    localStorage.setItem("trophies", String(trophies));
    localStorage.setItem("coins", String(coins));
    localStorage.setItem("rankRewardClaimedRank", String(rankRewardClaimedRank));
    localStorage.setItem("best", String(best));
    localStorage.setItem("snakeProgress", JSON.stringify(snakeProgress));
    localStorage.setItem("cosmetics", JSON.stringify(cosmetics));
    localStorage.setItem("dailyChallenges", JSON.stringify(dailyChallenges));
    persistHistory();

    setHudTrophiesValue(trophies);
    setHudCoinsValue(coins);
    updateBestDisplay();
    updateMenuTrophies();
    updateRank();
    renderSnakeProgress();
    applyCosmetics();
    syncSkinInputs();
    refreshChallengeUI();
    renderHistory();
    scheduleCloudSync(0);
}

document.getElementById("importHistoryBtn").addEventListener("click", () => {
    document.getElementById("importHistoryInput").click();
});

document.getElementById("mainExportProgressBtn").addEventListener("click", () => {
    exportFullProgressPayload();
});

document.getElementById("mainImportProgressBtn").addEventListener("click", () => {
    document.getElementById("importProgressInput").click();
});

document.getElementById("importHistoryInput").addEventListener("change", async (event) => {
    const input = event.target;
    const file = input.files && input.files[0];
    if(!file) return;

    try {
        const text = await file.text();
        const parsed = JSON.parse(text);
        const rawGames = Array.isArray(parsed)
            ? parsed
            : (Array.isArray(parsed.games) ? parsed.games : []);

        const importedGames = rawGames
            .map((game) => normalizeHistoryRecord(game, true))
            .filter(Boolean);

        if(!importedGames.length){
            alert("В файле нет валидных игр для импорта.");
            return;
        }

        gameHistory = [...importedGames, ...gameHistory].slice(0, 50);
        persistHistory();
        renderHistory();
        scheduleCloudSync(0);
        alert(`Импортировано игр: ${importedGames.length}`);
    } catch (e) {
        console.error(e);
        alert("Не удалось импортировать файл истории.");
    } finally {
        input.value = "";
    }
});

document.getElementById("importProgressInput").addEventListener("change", async (event) => {
    const input = event.target;
    const file = input.files && input.files[0];
    if(!file) return;

    try {
        const text = await file.text();
        const parsed = JSON.parse(text);

        const progressPayload = (parsed && typeof parsed === "object" && parsed.progress && typeof parsed.progress === "object")
            ? parsed.progress
            : parsed;

        applyImportedProgress(progressPayload);
        alert("Прогресс успешно импортирован.");
    } catch (e) {
        console.error(e);
        alert("Не удалось импортировать прогресс.");
    } finally {
        input.value = "";
    }
});
function saveGameToHistory(score, trophyChange, wasAI){

    const now = new Date();

    const record = normalizeHistoryRecord({
        date: now.toLocaleDateString(),
        time: now.toLocaleTimeString(),
        score: score,
        trophies: trophyChange,
        isAI: !!wasAI,
        noRewards: !!sessionNoRewards,
        imported: false,
        seed: replaySeed,
        inputs: Array.isArray(currentReplay) ? [...currentReplay] : [],
        foodHistory: Array.isArray(foodHistory) ? [...foodHistory] : [],
        finalFrame: gameFrame,
        duration: performance.now() - gameStartTime,
        initialSpeed: sessionStartSpeed,
        initialTargetLength: sessionStartTargetLength,
        initialDir: sessionStartDir
    }, false);

    if(!record) return;

    gameHistory.unshift(record); // добавляем в начало

    if(gameHistory.length > 50){
        gameHistory.pop(); // максимум 50 игр
    }

    persistHistory();
}

function renderHistory(){

    const container = document.getElementById("historyList");
    container.innerHTML = "";

    if(gameHistory.length === 0){
        container.innerHTML = "<p>Пока нет сыгранных игр</p>";
        return;
    }

    gameHistory.forEach((game, index) => {

        const div = document.createElement("div");

        div.style.padding = "10px";
        div.style.marginBottom = "8px";
        div.style.borderBottom = "1px solid #00ffff33";

        const isAIGame = !!game.isAI;
        const isTraining = !!game.noRewards;
        const isImported = !!game.imported;
        const normalizedTrophy = Number.isFinite(game.trophies) ? game.trophies : 0;
        const trophyText = (isAIGame || isImported || isTraining)
            ? "-"
            : (normalizedTrophy >= 0 ? "+" + normalizedTrophy : String(normalizedTrophy));
        const modeText = isImported
            ? (isAIGame ? "Импорт AI" : (isTraining ? "Импорт Тренировка" : "Импорт"))
            : (isAIGame ? "AI" : (isTraining ? "Тренировка" : "Игрок"));

        div.innerHTML = `
    <strong>${game.date} ${game.time}</strong><br>
    Режим: ${modeText}<br>
    Счёт: ${game.score}<br>
    Трофеи: ${trophyText}<br><br>
    <button class="replayBtn">Смотреть повтор</button>
    <button class="exportGameBtn">Экспорт игры</button>
`;

        const replayBtn = div.querySelector(".replayBtn");
        if (replayBtn) {
            replayBtn.addEventListener("click", () => watchReplay(index));
        }

        const exportGameBtn = div.querySelector(".exportGameBtn");
        if (exportGameBtn) {
            exportGameBtn.addEventListener("click", () => {
                exportGamesPayload([game], `game-${index + 1}`);
            });
        }

        container.appendChild(div);
    });
}
function watchReplay(index){

    const data = gameHistory[index];
    if(!data) return;

    currentReplayData = data;
    clearMutation();

    const replayInputs = sanitizeReplayInputs(data.inputs);
    const replayFoodsSafe = sanitizeFoodHistory(data.foodHistory);
    const replayFoods = replayFoodsSafe.length
        ? replayFoodsSafe
        : [randomFood()];

    const fallbackEndFrame = replayInputs.reduce((max, ev) => {
        const frame = Number.isFinite(ev.frame) ? ev.frame : 0;
        return Math.max(max, frame);
    }, 0) + Math.max(120, replayFoods.length * 25);

    const replayFinalFrame = Number.isFinite(data.finalFrame)
        ? data.finalFrame
        : fallbackEndFrame;
    const replayWasAI = !!data.isAI;

    isReplaying = true;
    running = true;
    aiMode = false;
    pendingPlayerDir = null;

    document.getElementById("historyMenu").classList.add("hidden");
    document.getElementById("mainMenu").classList.add("hidden");
    document.getElementById("gameOverMenu").classList.add("hidden");
    document.getElementById("exitBtn").classList.remove("hidden");
    syncMenuOverlayState();

    replaySeed = Number.isFinite(data.seed)
        ? data.seed
        : Math.floor(Date.now() % 1000000000);

    gameFrame = 0;
    replayFoodIndex = 0;
    accumulator = 0;

    init();

    score = 0;
    level = 1;
    targetLength = Number.isFinite(data.initialTargetLength) ? data.initialTargetLength : 120;
    speed = Number.isFinite(data.initialSpeed) ? data.initialSpeed : baseSpeed;
    updateSpeedDisplay();
    if (data.initialDir && Number.isFinite(data.initialDir.x) && Number.isFinite(data.initialDir.y)) {
        dir = { x: data.initialDir.x, y: data.initialDir.y };
    }

    updateScoreDisplay();
    document.getElementById("levelDisplay").innerText = level;

    food = {
        x: replayFoods[0].x,
        y: replayFoods[0].y,
        eaten: false
    };

    let replayFrame = 0;
    let inputIndex = 0;

    lastTime = performance.now();

    function applyReplayDirection(x, y){
        if (!Number.isFinite(x) || !Number.isFinite(y)) return;
        const nx = normalizeAxisValue(x);
        const ny = normalizeAxisValue(y);
        if (nx === null || ny === null) return;
        if (Math.abs(nx) + Math.abs(ny) !== 1) return;

        // Keep replay consistent with live controls: no instant 180 turn.
        if (dir && nx === -dir.x && ny === -dir.y) return;
        dir = { x: nx, y: ny };
    }

    function finishReplay(){
        running = false;
        isReplaying = false;
        document.getElementById("exitBtn").classList.add("hidden");
        document.getElementById("mainMenu").classList.remove("hidden");
        syncMenuOverlayState();
    }

    function replayLoop(timestamp){

        if(!running){
            finishReplay();
            return;
        }

        const delta = timestamp - lastTime;
        lastTime = timestamp;
        accumulator += delta;

        while(accumulator >= FIXED_STEP){

            // 1) До движения применяем только смену направления для текущего кадра.
            while(inputIndex < replayInputs.length){
                const event = replayInputs[inputIndex];
                if(event.frame < replayFrame){
                    inputIndex++;
                    continue;
                }
                if(event.frame > replayFrame) break;

                if(event.x !== undefined){
                    applyReplayDirection(event.x, event.y);
                    inputIndex++;
                    continue;
                }

                // eat обрабатывается после движения в том же кадре.
                break;
            }

            let move = speed * (FIXED_STEP/1000);

            const head = {
                x: snake[0].x + dir.x * move,
                y: snake[0].y + dir.y * move
            };

            snake.unshift(head);

            let length = 0;
            for(let i=1;i<snake.length;i++){
                const dx = snake[i].x - snake[i-1].x;
                const dy = snake[i].y - snake[i-1].y;
                length += Math.sqrt(dx*dx + dy*dy);
            }

            while(length > targetLength){
                snake.pop();
                length = 0;
                for(let i=1;i<snake.length;i++){
                    const dx = snake[i].x - snake[i-1].x;
                    const dy = snake[i].y - snake[i-1].y;
                    length += Math.sqrt(dx*dx + dy*dy);
                }
            }

            if(checkCollision()){
                break;
            }

            // 2) После движения применяем eat-события текущего кадра.
            while(inputIndex < replayInputs.length){
                const event = replayInputs[inputIndex];
                if(event.frame < replayFrame){
                    inputIndex++;
                    continue;
                }
                if(event.frame > replayFrame) break;

                if(event.eat){
                    score++;
                    updateScoreDisplay();

                    let newLevel = Math.floor(score / 5) + 1;
                    if(newLevel !== level){
                        level = newLevel;
                        speed += replayWasAI ? 22 : 30;
                        if (replayWasAI) {
                            speed = Math.min(speed, 620);
                        }
                        document.getElementById("levelDisplay").innerText = level;
                        updateSpeedDisplay();
                    }

                    targetLength += 40;
                    replayFoodIndex++;

                    if(replayFoodIndex < replayFoods.length){
                        food = {
                            x: replayFoods[replayFoodIndex].x,
                            y: replayFoods[replayFoodIndex].y,
                            eaten: false
                        };
                    }

                    inputIndex++;
                    continue;
                }

                // Любые direction-события для этого кадра уже отработали выше.
                inputIndex++;
            }

            replayFrame++;
            accumulator -= FIXED_STEP;

            if(replayFrame >= replayFinalFrame){
                running = false;
                break;
            }
        }

        draw();

        if(!running){
            finishReplay();
            return;
        }

        requestAnimationFrame(replayLoop);
    }

    requestAnimationFrame(replayLoop);
}

window.render_game_to_text = function renderGameToText() {
    const payload = {
        coordinateSystem: "origin top-left, +x right, +y down",
        running,
        replay: isReplaying,
        mode: aiMode ? "ai" : "player",
        score,
        level,
        coins,
        mutation: activeMutation
            ? { id: activeMutation.id, leftMs: Math.max(0, Math.round(mutationRemainingMs())) }
            : null,
        snakeLevel: snakeProgress.level,
        trophies,
        survivalMsCurrentRun: Math.round(survivalMsCurrentRun),
        head: snake && snake[0] ? { x: Math.round(snake[0].x), y: Math.round(snake[0].y) } : null,
        food: food ? { x: Math.round(food.x), y: Math.round(food.y) } : null,
        dailyChallenges: Array.isArray(dailyChallenges?.tasks)
            ? dailyChallenges.tasks.map((task) => ({
                type: task.type,
                progress: task.progress,
                target: task.target,
                done: task.done
            }))
            : []
    };
    return JSON.stringify(payload);
};

window.advanceTime = function advanceTime(ms) {
    if (!running || !Number.isFinite(ms) || ms <= 0) {
        draw();
        return;
    }
    const steps = Math.max(1, Math.round(ms / FIXED_STEP));
    for (let i = 0; i < steps; i++) {
        update(FIXED_STEP);
        if (!running) break;
    }
    draw();
};

</script>
</body>
</html>
